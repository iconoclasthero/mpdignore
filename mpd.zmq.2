#!/bin/bash
#export LC_CTYPE="UTF-8"
export TERM

#editscript(){
#  local scriptpath script path swp; scriptpath=$(realpath "$0" 2>/dev/null); script="${scriptpath##*/}"; path="${scriptpath%/*}"; swp="$path/.$script.swp"
#     [[ ! -e "$swp" ]] && printf "\n\n%s\n\n" "$swp" && (/usr/bin/nano "$scriptpath") && exit
#     printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptpath" "$swp"; exit ;}
#
#[[ "$1" = @(edit|e|-e) ]] && editscript && exit

. /usr/local/bin/editscript
. mpdignore.functions

[[ "$mpdhost" = "$(hostname)" ]] && exit 1
shopt -s nullglob

       bold="$(tput bold)"
      tput0="$(tput sgr0)"
     yellow="$(tput setaf 214)"
       blue="$(tput setaf 33)"
    boldred="$(tput bold setaf 9)"
    tunport="$mpdzmqtunport"
    retport="$mpdzmqretport"
 autosshpid="/tmp/autossh_${tunport}.pid"
 ffplaypidf="/tmp/ffplayzmq-$(date -Im).pid"
 mpdzmqvarf="/tmp/mpdzmqvar-$(date -Im).tmp"
   sinkID00='00:42:79:D9:B6:AF'
 sinkname00='JBL Xtreme 2'
   sinkID01='00:1F:47:9F:8C:57'
 sinkname01='LG SOUND BAR'
   sinkID02='C8:2B:6B:49:A6:A3'
 sinkname02='JBL TUNE510BT'
   sinkID03='sink-59'
 sinkname03='Built-in Audio Analog Stero (latitude)'
   sinkID04='sink-48'
 sinkname04='Built-in Audio Analog Stero (compaq)'
export GREP_COLORS='mt=38;5;33'

mksinkarray(){
  ## this function creates an assoc. array of [sinkname]=sinkID pairs
  local s namevar macvar testsink              ## declare function locals
  declare -gA sinkarray                        ## declare global assoc. array
  declare -ga sinkorder                        ## declare global indexed array

  [[ "$1" ]] && testsink="$1"                  ## if an argument is passed check if it is a valid sinkname
  if [[ "$testsink" ]]; then                   ## this assumes that mksinkarray is run before main flag processing
    for i in "${sinkorder[@]}"; do             ## and thus the sink arrays will already be populated.
      [[ "$testsink" = "$i" ]] && return 0
    done
    return 1
  fi

  for s in $(compgen -A variable); do          ## do not quote shell substitution or it won't work!
    if [[ "$s" = sinkname[0-9][0-9] ]]; then   ## up to 100 sink pairs ∴ zeropad var names
      sinkorder+=("${!s}")
      n="${s#sinkname}"                      ## strip prefix to get 01, 02, etc.
      IDvar="sinkID$n"
      sinkarray["${!s}"]="${!IDvar}"        ## array additions; s=sinkname??
    fi
  done
}

pause(){ echo "$@" ; read -rp "contents" < /dev/tty; }

showhelp(){
cat <<EOF
Usage: $0 [OPTIONS]

A script for controlling various media and remote actions.

Options:
  -e, e, edit            Edit the script and exit.
  --ip <remote_ip>       Specify the remote IP for ZMQ communications.
  --port, -p <port>      Specify the remote port for ZMQ communications.
  --reset, --restart     Reset or restart the ZMQ service.
  -v, --verbose          Enable verbose output.
  --quit, --exit,        Stop the media player and tunnel; optionally...
  q[uit], exit              ...pause mpd and disconnect BT speaker.
  pause                  Pause the media playback.
  play                   Resume the media playback.
  -h, --help, help       Display this help information.
EOF
}

hr(){
  local width="$(tput cols)"
#  local width=${1:-${COLUMNS:-80}}  # Default to 80 if COLUMNS is unset
#  printf -- '%.0s—' $(seq "${1:-$COLUMNS}"); echo; }
  printf -- '%.0s—' $(seq 1 "$width"); echo; }

resetzmq(){
  btctlout+="$(bluetoothctl disconnect "$sinkID00"|grep -v "Attempting to disconnect from $sinkID00")"
  printf '\n%s%sAttempting to disconnect %s%s/%s%s:%s\n%s\n' \
    "$yellow" \
    "$bold" \
    "$blue" \
    "$sinkname00" \
    "$sinkID00" \
    "$yellow" \
    "$tput0" \
    "$btctlout"
  printf %s\\n "$(hr)"

  echo
  before=before
  for j in psaux pkill psaux; do
    printf %s%s "$bold" "$yellow"
    [[ "$j" = psaux ]] && echo "$j $before:" || echo "$j:"
    printf %s "$tput0"
    for i in autossh ffplay bin/mpd.zmq; do
      "$j" "$i"|grep -v -- '--reset'
    done
    [[ "$before" = before ]] && before=after
    hr
    echo
  done
  pause "${yellow}${bold}^C to exit, [Enter] to continue.${tput0}"
  hr
}


startautossh(){
  local psout ecss ecauto sshpid
  : "${autosshpid:=/tmp/autosshpid_$tunport.pid}"
# if ! ps aux | grep "[a]utossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}" > /dev/null; then   #moving from ps aux to ss:
# if ! ssout=( ss -tlnp | grep -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]\)\)" ); then
# if ! ssout=( "$(ss -tlnp | grep --color=always -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]\)\)")" ); then


  unset ecss ecauto
  ## more permissive: tmp="$(ss -tlnp | grep -E "LISTEN.+:${tunport}.*users:\(.*(ssh|autossh)")"
  tmp="$(ss -tlnp |grep -E "Listen.+:${tunport}.*users:\(+\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]{1,2}\)+")"
  ecss="$?"
  readarray -t ssout <<<"$tmp"

  (( verbose == 2 )) && { printf '${ssout[@]}: %s\n' "${ssout[@]}"; }

  if ! (( ecss )); then
    (( verbose == 2 )) && { printf '$ecss: %s\n' "$ecss"; }
    sshpid="${ssout#*pid=}"; sshpid="${sshpid%%,*}"
    readarray -t pidcheck < <(ps -fp "$sshpid")
    (( verbose == 2 )) && { printf '${pidcheck[@]}: %s\n' "${pidcheck[@]}"; }
    if (( "${#pidcheck[@]}" == 2 )); then  ## there's exactly one matching process
      if printf %s\\n "${pidcheck[2]}"|grep -v "ssh: $HOME/.ssh/$USER@$mpdhost:$sshport \[mux\]"; then
        printf 'The script using an established muxed ssh connection on PID %s:\n  %s' "$sshpid" "$(ps -fp "$sshpid")" > "${autosshpid}"
      else
        printf 'The script may be (re)using an existing ssh connection on PID %s\n %s' "$sshpid" "${psout[@}}" > "${autosshpid}"
      fi
    fi

    (( verbose == 2 )) &&
      { printf -- 'tunnel status:\n  ss -tlnp\n%s\n\n' "${ssout[*]}"
        screen -ls
        psaux 5555
        psaux ffplay
      }
  else
    (( verbose == 2 )) && { printf '$ecss: %s\n' "$ecss"; }
    confirm -Y "No exising [auto]ssh found. Establish a new connection? " ||
      { printf 'No open [auto]ssh connection found! (return 1)\n'; return 1; }
    printf '\n\n\n\n\nNB: The autossh command does not have a failed exit code so right now there is no verification it has succeeded!\n'
    printf 'If it becomes an issue try e.g., `timeout 2 bash -c "</dev/tcp/localhost/${tunport}" 2>/dev/null && echo "Tunnel up" || echo "Tunnel down"`\n\n\n\n\n.'
    autoarr=(autossh -fvN -M0 -L "${tunport}:localhost:${tunport}" "$mpdhost" -p "${sshport}")
   "${autoarr[@]}"
    ecauto="$?"
## this is probably wrong, why would a 0 exit code be unsuccessful?
#    ! (( ecauto )) && { printf '%s[ERROR]%s unable to open the tunnel\nexit 1' "${boldred}" "$tput0"; exit 1; }
    (( ecauto )) && { printf '%s[ERROR]%s unable to open the tunnel\nexit 1' "${boldred}" "$tput0"; exit 1; }
    \sleep 1
    autossh_pid=$(pgrep -f "autossh/autossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}")
    printf %s\\n "$autossh_pid" > "${autosshpid}"  #this might be the right pid?
  fi


#
#Purpose of -f in autossh
#-f (fork): This flag causes autossh to fork into the background, which is often desirable if you don't want your terminal to stay tied to the process. It makes the SSH connection run in the background, so the user can continue using the terminal for other tasks. This is useful when you're scripting or need a long-running SSH session without blocking the shell.
#Why Remove -f in My Suggestion?
#When -f is used, the parent shell forks first, then autossh forks and detaches into the background. As a result, the PID you capture using $! is of the shell's child process, not the final autossh process. That's why I initially suggested removing -f, as it allows you to more reliably capture the correct autossh PID.
#
#Compensation for Removing -f:
#By removing -f, you're preventing autossh from forking into the background. To compensate for this, I added & at the end of the command:
#
#bash
#Copy code
#autossh -vN -M0 -L"${tunport}":localhost:"${tunport}" -R"${retport}":localhost:22 "${mpdhost}" -p"${sshport}" &
#This & ensures that the command runs in the background, but without the double-forking behavior that the -f flag triggers. This allows you to capture the correct autossh PID using pgrep.
#
#If You Still Want to Use -f:
#If you absolutely need the -f flag (for instance, if the behavior of autossh requires it to double-fork and detach), you can keep it, but capturing the PID becomes trickier. You'll have to rely on pgrep or ps after the process has forked into the background.
#
#Here’s how you can still use -f and capture the correct PID:
#
#bash
#Copy code
#startssh() {
#  if ! ps aux | grep "[a]utossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}" > /dev/null; then
#    autossh -fvN -M0 -L"${tunport}":localhost:"${tunport}" -R"${retport}":localhost:22 "${mpdhost}" -p"${sshport}"
#    sleep 1  # Give autossh some time to fork and start
#    autossh_pid=$(pgrep -f "autossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}")
#    echo "${autossh_pid}" > "${autosshpid}"
#  fi
#}
#Why This Works:
#-f is still there, so autossh will run in the background just as before.
#pgrep finds the correct autossh process after it forks, using the command-line pattern to match the process.
#This method keeps the original background behavior while ensuring you capture the right PID.
}

ChatGPT_proposed_startautossh(){
    local tmp ssout sshpid

    : "${autosshpid:=/tmp/autosshpid_$tunport.pid}"

    # check if anything is listening on the tunport
    tmp=$(ss -tlnp | grep -E "LISTEN.+:${tunport}.*users:\(+\"(ssh|autossh)\"")
    readarray -t ssout <<<"$tmp"

    if (( ${#ssout[@]} )); then
        # pick the first matching PID, ignore system mux
        sshpid="${ssout[0]#*pid=}"
        sshpid="${sshpid%%,*}"

        # make sure it's not the service mux
        if ps -fp "$sshpid" | grep -vq "ssh: $HOME/.ssh/$USER@$mpdhost:$sshport \[mux\]"; then
            printf 'Using existing user autossh PID %s\n' "$sshpid"
            printf '%s\n' "$sshpid" > "$autosshpid"
            return 0
        else
            printf 'Detected service mux; leaving it alone\n'
            return 0
        fi
    fi

    # no tunnel, ask to start
    confirm -Y "No open user autossh found. Establish new connection? " || return 1

    autossh -f -M0 -N -L "${tunport}:localhost:${tunport}" "$mpdhost" -p "$sshport"
    sleep 1

    # check if tunnel came up
    timeout 2 bash -c "</dev/tcp/localhost/$tunport" &>/dev/null || {
        printf '[ERROR] Unable to open tunnel\n'
        return 1
    }

    # record PID of the new connection
    sshpid=$(pgrep -f "autossh.*-L${tunport}:localhost:${tunport}.*$mpdhost.*-p${sshport}")
    printf '%s\n' "$sshpid" > "$autosshpid"
    printf 'New autossh PID %s recorded\n' "$sshpid"
}




startffplay(){
  readarray -t rmpidout < <(rm /tmp/ffplayzmq-????-??-??T??\:??-0{4,5}\:00.pid 2>&1)

  for line in "${rmpidout[@]}"; do
    if [[ "$line" != "rm: cannot remove '/tmp/ffplayzmq-"????\-??\-??\T??\:??\-\0?":00.pid': No such file or directory" ]]; then
      echo "$line"
#   else
#     printf suppressed\ error\:\ %s\\n "${rmpidout[@]}"
    fi
  done

  screen -dmS mpd.zmq sh -c \
    'ffplay -protocol_whitelist "file,rtp,udp,zmq,tcp" -autoexit -nodisp zmq:tcp://localhost:5555 -loglevel debug & echo $! > "$0"; wait' \
    "${ffplaypidf}"
}
##--> startffplay() <--###############################################################################

stopffplay(){
  local screenls found
  (( verbose )) && { printf '\n%sLooking for open mpd.zmq screens...\n%s' "$yellow" "$tput0"; hr; }
  while screenls="$(screen -ls | grep -E '[[:digit:]]+\.mpd\.zmq')"; do
    (( verbose )) && printf 'Resetting matching screen:\n%s\n' "$screenls"
    screen -S mpd.zmq -X quit &>/dev/null
    screen -wipe &>/dev/null
    found=1
  done
  [[ ! "$screenls" ]] && (( verbose && ! found )) && printf '%sNo matching screens found.%s\n' "${blue}" "$tput0"
  (( verbose )) && hr
}
##--> stopffplay() <--################################################################################


confirm(){
  local ans dans
  [[ "$1" = -[Yy] ]] && { dans=Y; shift; }
  [[ "$1" = -[Nn] ]] && { dans=N; shift; }
  while IFS= read -rp "$1" -n1 ans; do
    [[ ! "$ans" && "$dans" ]] && ans="$dans"
    printf \\n
    case "$ans" in
      [Yy]) return 0;;
      [Nn]) return 1;;
    esac
  done
}
##--> confirm() <--###################################################################################

stopmpdzmq(){
  local stopautossh=false
  local stopzmqscreen=false
  local nine ffplaypid ffplaypidf ffnine mpdzmqvarf mpdzmqvarfiles

  mpdzmqvarfiles=( /tmp/mpdzmqvar-*.tmp )
  (( "${#mpdzmqvarfiles[@]}" )) && mpdzmqvarf=( "${mpdzmqvarfiles[-1]}" )

  [[ -f "$mpdzmqvarf" ]] && . "$mpdzmqvarf" &&
     { echo "sinkname=${sinkname:-null}"
       printf 'cat of $mpdzmqvarf (source succeeded):\n'
       while read -r line; do
         printf '  %s\n' "$line"
       done < "$mpdzmqvarf"
       printf \\n; }


  while ! "$stopautossh" || ! "$stopzmqscreen" ; do
    (( verbose )) && printf '$stopautossh=%s\n' "$stopautossh"
    (( verbose )) && printf '$stopzmqscreen=%s\n' "$stopzmqscreen"
    stopffplay
    local autossh_pid
    [[ -f "$autosshpid" ]] && autossh_pid="$(cat "$autosshpid")"
    if (( autossh_pid )) 2>/dev/null; then
      killcmd=( kill )
      [[ "$nine" ]] && killcmd+=( "$nine" )
      killcmd+=( "$autossh_pid" )
      "${killcmd[@]}"
      echo
    fi
#    screenlsout="$(screen -ls|grep --color=always mpd.zmq)"
#    if [[ "$screenlsout" && ! "$stopzmqscreen" ]]; then
    if screenlsout="$(screen -ls|grep --color=always mpd.zmq)" && [[ ! "$stopzmqscreen" ]]; then
      if [[ "$ffplaypid" ]]; then
        ffkillcmd=( kill )
        [[ "$ffnine" ]] && ffkillcmd+=( "$ffnine" )
        ffkillcmd+=( "$ffplaypid" )
        (( verbose )) && printf 'Running kill ffmpeg command: %s\n' "${ffkillcmd[@]}"
        "${ffkillcmd[@]}"
        ffnine='-9'
      fi
      printf '%s%sThe output of `screen -ls|grep mpd.zmq` should be empty: \n%s' "$bold" "$yellow" "$tput0"
      hr
      echo "$screenlsout"
      hr
      echo
      confirm "Are the mpd.zmq screens closed? " && stopzmqscreen=true
#      ffplaypidf=( /tmp/ffplayzmq-*.pid )
#      ffplaypid=$(< "${ffplaypidf[-1]}" )
    else
      printf '\n%s%sThe ffplay and the mpd.zmq screen are closed.\n%s' "$bold" "$yellow" "$tput0"
      hr
      stopzmqscreen=true
    fi
    psaux5555="$(ps aux|grep --color=never "[${tunport:0:1}]${tunport:1}"|grep --color=always -E autossh\|ffplay\|"$mpdhost")"
    if [[ "$psaux5555" && ! "$stopautossh" ]]; then
      printf 'The output of `psaux 5555` should be empty: \n'
      hr
      echo "$psaux5555"
      hr
      echo
      confirm "${yellow}${bold}Are ffplay and autossh closed? $tput0" && stopautossh=true
      nine='-9'
    else
      printf '%s%s\nNo mpd.zmq autossh tunnel is open.\n%s' "$bold" "$yellow" "$tput0"
      hr
      stopautossh=true
    fi
  done

  ## load variables:
  ## choosesink
  ## sinkin
  ## onsink
  ## sinkout
  ## sinkMAC
  ## sinkname
  ## sinkPAID
  ## ffplaypid

  if [[ "$sinkMAC" =~ ^[A-F0-9]{2}(:[A-F0-9]{2}){5} ]] &&
    printf \\n
        confirm "${yellow}${bold}Disconnect Bluetooth speaker $sinkname ($sinkMAC)? $tput0"; then
    (( verbose )) && printf '$sinkMAC=%s\n' "${sinkMAC:-null}"
    hr
    printf \\n
    { btctlout="$(bluetoothctl disconnect "$sinkMAC")" &&
      printf "$btctlout"|grep --color=always -E Attempting\ to\ disconnect\ from\ "$sinkMAC"\|Successful\ disconnected; } ||
      printf '[ERROR] Disconnect from Bluetooth speaker unsuccessful. Investigate:\n\n%s\n' "$(printf \ \ %s\\n "${btctlout[@]}")"
    printf \\n
  fi

  echo
  confirm "${yellow}${bold}Pause mpd on $mpdhost? $tput0" && { hr;  mpctitle pause; }
  rm -- "${ffplaypidf[@]}" 2>/dev/null || rm -f -- /tmp/ffplayzmq-*.pid
  rm -f -- /tmp/autossh_5555.pid
  (( "${#mpdzmqvarfiles[@]}" )) && rm -- "${mpdzmqvarfiles[@]}"
  ## won't work because glob does not expand:  rm -- "${ffplaypidf[@]:-/tmp/ffplayzmq-*.pid}"
  exit 0
}
##--> stopmpdzmq() <--###################################################################################

connectBT(){
  local btctlout=("$(bluetoothctl list)")
#debug output
#  echo "btctlout+=(\"$(bluetoothctl connect \"$sinkID00\" 2>&1)\") &&"
  btctlout+=("$(bluetoothctl connect "$sinkID00" 2>&1)") &&
    connected=yes || connected=no
#debug output
#  echo "btctlout+=(\"$(bluetoothctl info "$sinkID00")\")"
  btctlout+=("$(bluetoothctl info "$sinkID00")")
#debug output
#  printf %s\\n%s\\n\\n "$connected" "$(declare -p btctlout)"

# this had to be added because the echo > fifo is blocking and the command will not complete until there's a reader, but that's not going to happen:

  tail -f "$btctlfifo" > /dev/null &
  readerpid=$!
  { echo "$connected"
    declare -p btctlout
  } > "$btctlfifo"

#debug output
 printf '\n\nExiting function %s (exit %s)' "$FUNCNAME" "$?"
# kill "$readerpid"
}

connectBT(){
  local connected
  (( verbose )) && printf 'Entering %s\n' "$FUNCNAME" | tee -a /tmp/mpd.zmq.log
  for s in "${sinkorder[@]}"; do
    ID="${sinkarray[$s]}"
    if [[ "$ID" =~ ^[A-F0-9]{2}(:[A-F0-9]{2}){5} ]]; then
      (( verbose == 2 )) && printf 'Attempting to connect to BT device %s...\n' "$s" >> /tmp/mpd.zmq.log
      btctlout=("$(bluetoothctl list)")
      (( verbose == 2 )) && printf 'btctlout=("$(bluetoothctl list)")\n' >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf 'btctlout=("%s")\n' "$(bluetoothctl list)" >> /tmp/mpd.zmq.log
      btctlout+=("$(bluetoothctl connect "$ID" 2>&1)") &&
        connected=yes || connected=no
      (( verbose == 2 )) && printf 'btctlout+=("$(bluetoothctl connect "$sinkID00" 2>&1)") &&\n  connected=yes || connected=no\n' >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf 'btctlout+=("%s") &&\n' "$(bluetoothctl connect "$ID" 2>&1)" >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf 'connected=%s\n' "$connected" >> /tmp/mpd.zmq.log
      btctlout+=("$(bluetoothctl info "$ID")")
      (( verbose == 2 )) && printf 'btctlout+=("$(bluetoothctl info "$sinkID00")")\n' >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf 'btctlout+=("%s")\n' "$(bluetoothctl info "$ID")" >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf '\n\nconnected=%s\n' "$connected" >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf %s\\n "${btctlout[@]}" >> /tmp/mpd.zmq.log
      (( verbose == 2 )) && printf \\n
      if [[ "$connected" = yes ]]; then
        (( verbose == 2 )) && printf '%sBLUETOOTH DEVICE %s CONNECTED!\n%s' "$blue" "$s" "$tput0"
        sinkname="$s"
        sinkMAC="$ID"
        for (( c=0; c<20; c++ )); do # for c in {1..5}; do
          sinkPAID="$(pulsemixer --list-sinks|awk -v sn="$sinkname" '$0 ~ sn {sub(/,$/,"",$3); print $3}')"
          [[ "$sinkPAID" =~ ^sink-[0-9]+$ ]] && break
          sleep 0.5s
        done
        (( verbose == 2 )) && printf ' $sinkname = %s\n' "$sinkname"
        (( verbose == 2 )) && printf '  $sinkMAC = %s\n' "$sinkMAC"
        (( verbose == 2 )) && printf ' $sinkPAID = %s\n' "$sinkPAID"
        (( verbose == 2 )) && printf '$connected = %s\n' "$connected"
        break
      fi
    fi
  done

# this had to be added because the echo > fifo is blocking and the command will not complete until there's a reader, but that's not going to happen:

 # tail -f "$btctlfifo" > /dev/null &
 # readerpid=$!
#  { echo "$connected"
#    declare -p btctlout
#  } > "$btctlfifo"
  { declare -p connected sinkname sinkMAC sinkPAID
    declare -p btctlout
  } > "$btctlfifo"
  ret="$?"

 (( verbose==2 )) && printf '%s\\n' "${btctlout[@]}"
 (( verbose==2 )) && declare -p btctlout

 printf '\n\nExiting function %s (return %s)\n' "$FUNCNAME" "$ret"
 return "$ret"
# kill "$readerpid"
}


remote-zmq(){
  local zmqport
  local remote="$1"; shift
  [[ "$1" = -@(-port|p) ]] && zmqport="$2"; shift 2
  sshargs=( 'ssh' )
  sshargs+=( '-t' )
  [[ "$zmqport" ]] && sshargs+=( "-p$zmqport" )
  sshargs+=( '--' )
  sshargs+=( "$remote" )
  sshargs+=( 'mpd.zmq' )
  sshargs+=( "$@" )
# ssh -t "$remote" mpd.zmq "$@"
# ssh $(printf %s\  "${sshargs[@]}")
  "${sshargs[@]}"
  exit "$?"
}

############################################################################################################
# mpd.zmq main block
############################################################################################################

mksinkarray ## call function to create the sink array first to test --choose "$2"


while (( "$#" )); do
  [[ "$1" =  @(--help|-h|help) ]] && { showhelp; shift; exit; }
  [[ "$1" =             --port ]] && { port="$2"; remote-zmq "$remote" "$@"; shift 2; continue; }
  [[ "$1" =               --ip ]] && { remote="$2"; remote-zmq "$remote" "$@"; shift 2; continue; }
  [[ "$1" = --@(reset|restart) ]] && { resetzmq; shift; continue; }
  [[ "$1" =    @(--verbose|-v) ]] && { verbose=1; shift; continue; }
  [[ "$1" = @(--quit|q@(|uit)) ]] && { quit=1; shift; continue; }
  [[ "$1" =              pause ]] && { pkill -19 ffplay; exit; }  # -SIGSTOP
  [[ "$1" =               play ]] && { pkill -18 ffplay; exit; }   # -SIGCONT
  [[ "$1" = @(--choose|--sink) ]] && { choosesink=1; if [[ "$2" ]] && mksinkarray "$2"; then sinknamesel="$2"; shift 2
                                                     else shift; fi; continue; }
  { printf '%s is unrecognized.\n' "$1"; shift
     { confirm -y 'Proceed with script?' && continue; } || exit 1; }
done

(( quit )) && {	stopmpdzmq; exit; }



if (( choosesink )) && [[ ! "$sinknamesel" ]]; then
  printf \\n
  sinknamesel="$(gum choose --cursor.foreground="33"  --header.foreground="214" --selected.foreground="33" --header="Choose a bluetooth device/sink from list:" "${sinkorder[@]}")" ||
   { printf 'User aborted. (exit 130)\n' ; exit 130; }
  sinksel="${sinkarray[$sinknamesel]}"
  printf '%sBluetooth/sink device %s = %s chosen.%s\n' "$blue" "$sinknamesel" "$sinksel" "$tput0"
  read -n1 -rp "Any key to continue (Control-C exits)..."
  sinkorder=( "$sinknamesel" )
elif (( choosesink )); then
  sinkorder=( "$sinknamesel" )
fi

(( verbose == 2 )) && printf '\n%sCreating btctlfifo with mkfifo...$s\n%s\n' "$yellow" "$tput0" "$(hr)"
tmpdir=$(mktemp -d)
btctlfifo=$(mktemp -u "$tmpdir/fifo_XXXX")
mkfifo "$btctlfifo"
(( verbose == 2)) && printf '  btctlfifo=%s\n%s\n' "$btctlfifo" "$hr"

## instead of looking just for the BT connections, we should go through the sinks in order of what is in the mpd.zmq.conf file but we'll need to determine if they're known BT sinks.  this will be obviated by selecting a sink first, but then that requires user input to guide it.

## this for loop will look to see if any of the BT devices (as determined by if 'sinkID??' is a MAC address)
##  are connected, in order of sinkarray[@]

printf '\n%sChecking for a connected Bluetooth device or PulseAudio sink...%s\n%s' "$yellow" "$tput0" "$(hr)"
for s in "${sinkorder[@]}"; do
  ID="${sinkarray[$s]}"
  (( verbose == 2 )) && printf 'ID=%s\n' "${sinkarray[$s]}"
  (( verbose == 2 )) && printf '$ID=%s\n' "$ID"

  if [[ "$ID" =~ ^[A-F0-9]{2}(:[A-F0-9]{2}){5} ]]; then
    (( verbose == 2 )) && printf '$ID = %s is validated as a MAC address.\n' "$ID"
    connected=$(bluetoothctl info "$ID"|awk '$1=="Connected:" {print $2}')
    sinkname="$s"
    sinkMAC="$ID"
    if [[ "$connected" = yes ]]; then
      printf '  %s%s already connected!\n%s' "$blue" "$s" "$tput0"
      sinkPAID="$(pulsemixer --list-sinks|awk -v sn="$sinkname" '$0 ~ sn {sub(/,$/,"",$3); print $3}')"
      break
    else
      printf '  %s not connected.\n' "$s"
      connected='no'
    fi
    (( verbose )) && printf '  $sinkname = %s\n' "$sinkname"
    (( verbose )) && printf '   $sinkMAC = %s\n' "$sinkMAC"
    (( verbose )) && printf '  $sinkPAID = %s\n' "${sinkPAID:=null}"
    (( verbose )) && printf ' $connected = %s\n' "$connected"
  elif [[ "$ID" =~ ^sink-[0-9]+$ ]] && (( choosesink )); then  ## if a non-BT sink was chosen then connect now.
    choosesink=2                                               ## PA should automatically fallback to an existing sink
    pulsemixer --list-sinks |\grep -q "$ID" &&
      connected='yes' || connected='no'
    ! (( verbose )) && printf 'Device chosen is a non-Bluetooth PulseAudio sink.\n'
    sinkname="$s"
    unset sinkMAC
    sinkPAID="$ID"
    [[ "$connected" = yes ]] && printf '\nPulseAudio sink connected: %s = %s\n' "$sinkname" "$sinkPAID"
#   [[ "$connected" = no ]] && { printf 'Invalid pulse sink selected. Investigate. (exit 1)\n'; exit 1; }
    [[ "$connected" = no ]] && { printf 'Invalid pulse sink selected. Investigate.\n'; }
    (( verbose )) && printf ' $sinkname = %s\n' "$sinkname"
    (( verbose )) && printf '  $sinkMAC = %s\n' "$sinkMAC"
    (( verbose )) && printf ' $sinkPAID = %s\n' "$sinkPAID"
    (( verbose )) && printf '$connected = %s\n' "$connected"
  fi
done

hr

printf \\n

#if [[ "$connected" = no && "$sinkMAC" ]]; then
if [[ "$connected" = no ]] && (( choosesink < 2 )); then  ## try connect first available BT device if a PA sink wasn't chosen
 (( verbose || logging )) && { printf 'Calling connectBT&\n' | { (( logging )) && tee -a /tmp/mpd.zmq/log || cat; }; }
  connectBT&
elif (( verbose )) && [[ "$sinkMAC" ]]; then
  btctlout=( "$sinkname00/$sinkMAC was already connected." "$(bluetoothctl list)" "$(bluetoothctl info $sinkID)" )
  (( verbose == 2 )) && printf %s\\n "${btctlout[@]}"
elif (( verbose == 2 )) && [[ ! "$sinkMAC" ]]; then
  printf 'In the if block to connectBT() but this is a non-BT device.\n\n'
fi

(( verbose )) && printf '%sCheck/start autossh...%s\n%s\n' "$yellow" "$tput0" "$(hr)"
startautosshout=( "$(startautossh&)" )
(( verbose )) && printf 'Need to figure out what should go here if the autossh is already running?  Remove?\n%s\n\n' "$(hr)"

#pause "$(printf '%srestarting ffplay screen%s\n\n' "$bold" "$tput0")"
#pause "${bold}restarting ffplay screen$tput0"
stopffplay

if (( verbose )); then
  if screenout=$(screen -ls mpd.zmq); then
    printf '\n[%sError%s] %s%smpd.zmq screens are still open: \n%s%s%s%s' "$red" "$tput0" "$yellow" "$bold" "$tput0" "$(hr)" "$blue" "$screenout" "$tput0"
  else
    printf '\n%s%sNo mpd.zmq screens are open:%s \n%s%s%s%s' "$yellow" "$bold" "$tput0" "$(hr)" "$blue" "$screenout" "$tput0"
  fi
    printf %s\\n "$(hr)"
fi
#fg >/dev/null

startffplayout=( "$(startffplay&)" )

zmqoutput="$(mpcp outputs|\grep ffmpeg\/zmq|awk '{print $2}')"
enableout=$(mpcp enable "$zmqoutput")
#(( verbose )) && printf '$enableout = %s\n' "$enableout"
playout=$(verbose=0 mpctitle play 2>/dev/null)
#(( verbose )) && printf '$playout = %s\n' "$playout"
pulsemixer --unmute

(( verbose==2 )) && printf 'before if: connected = %s\n' "$connected"

if [[ "$connected" = no && "$sinkMAC" != 'pulsesink' ]]; then
  printf 'Reading from btctlfifo (%s)...\n' "$btctlfifo"
#  IFS= read -r connected < "$btctlfifo"  # this should grab just one line (no while)
  . "$btctlfifo" # rest of FIFO
#  kill "$readerpid"
fi
#elif [[ ! "$sinkMAC" ]]; then
  btctlout+=( "PulseAudio sink:" )
  readarray -d, arr < <( pulsemixer --list-sinks|\grep "$sinkPAID" )
  for (( i=0; i<=${#arr[@]}; i++)); do
    if ! (( i )); then
      btctlout+=( " Sink ID: ${arr[$i]#*ID: }" )
      :
    elif [[ "${arr[$i]}" != \ Volumes* || "${arr[$i]}" = \ Volumes*\] ]]; then
      btctlout+=( "${arr[$i]}" )
    else
      btctlout+=( "${arr[$i]}${arr[$i+1]}" )
      (( i++ ))
    fi
  done

#fi

#(( verbose == 2 )) && printf 'sinkPAID=%s\n' "${sinkPAID#sink-}"
#unset active
#while read -r line; do
# [[ "$line" = Card\ \#* ]] && sinkcard="$line"
# [[ "$line" = "Name: bluez_card.${sinkMAC//:/_}" ]] && active=1 && (( verbose == 2 )) &&
#   { sinkcardname="$line"; printf %s\\n%s\\n "$sinkcard" "$sinkcardname"; }
# (( active )) && [[ "$line" =~ Active\ Profile\:\ (.*) ]] &&
#    { (( verbose == 2 )) && printf %s\\n "$line"
#      sinkcodec="${BASH_REMATCH[1]}"; btctlout+=( " Sink codec: $sinkcodec" ); break; }
#done < <(pactl list cards)
#unset active
#(( verbose == 2 )) && printf %s\\n "btctlout[-1]=${btctlout[-1]}"




(( verbose == 2 )) && printf 'sinkPAID=%s\n' "${sinkPAID#sink-}"
unset found
namematch="Name: bluez_card.${sinkMAC//:/_}"
while IFS= read -r line; do
  if [[ "$line" = Card\ \#* ]]; then
    (( found )) && break                    ## stop when next card starts
    cardinfo=( "$line" )                    ## reset cardinfo at new card
    sinkcard="${line#*#}"
  elif [[ "$line" = *"$namematch" ]]; then
    found=1
    cardinfo+=("$line" )
    sinkcardname="${line#*: }"
#  elif (( found )); then
   else
    cardinfo+=( "$line" )
    if [[ "$line" =~ Active\ Profile:\ (.*) ]]; then
      sinkcodec="${BASH_REMATCH[1]}"        ## capture codec
    fi
  fi
done < <(pactl list cards)
unset found

btctlout+=( " Sink codec: $sinkcodec" ) # add codec to downstream output

(( verbose == 2 )) && printf '$found=%s\n' "$found"
(( verbose == 2 )) && printf '$namematch=%s\n' "$namematch"
(( verbose == 2 )) && printf '$sinkMAC=%s\n' "$sinkMAC"
(( verbose == 2 )) && printf '${sinkMAC//:/_}=%s\n' "${sinkMAC//:/_}"
(( verbose == 2 )) && printf '$sinkcard=%s\nsinkcardname=%s\n' "$sinkcard" "$sinkcardname"
(( verbose == 2 )) && printf '$sinkcodec=%s\n' "$sinkcodec"
(( verbose == 2 )) && printf '${btctlout[-1]}=%s\n' "${btctlout[-1]}"
for i in "${cardinfo[@]}"; do
  [[ "$i" = *"$sinkcodec: "* ]] && sinkcodecdesc="${i#*$sinkcodec: }" && break
done
(( verbose == 2 )) && printf '$sinkcodecdesc=%s\n' "$sinkcodecdesc"
btctlout+=( " Sink codec description: $sinkcodecdesc" )

## this might need to be generalized more since it isn't necessarily choosing the right sink?

if (( choosesink )); then
  ## get the new PA input sink:
  ffplaypid="$(< "$ffplaypidf" )"
  (( verbose == 2 )) && printf 'ffplaypid: %s\n' "$ffplaypid"

  i=0
  until (( onsink || i > 10 )); do
    while read -r line; do
      [[ "$line" = "Sink Input #"* ]] && sinkin="${line#*#}"
      [[ "$line" = *Sink:\ * ]] && onsink="${line#*: }"
      [[ "$line" = *application.process.id* && "${line##* }" = "$ffplaypid" ]] && break 2
    done < <(pactl list sink-inputs)
    sleep 0.5s
    (( i++ ))
  done

  (( verbose )) && { printf '\n%sffplay sink input/output:%s\n' "$yellow" "$tput0"; hr;
                     printf 'ffplay is on sink input %s playing on output %s.\n' "$sinkin" "$onsink"; hr; }

#  if [[ "$onsink" != "$sinkPAID" && "$sinkPAID" =~ ^sink-[0-9]+$ ]]; then
#    sinkout="${sinkPAID#sink-}"
  if [[ "$sinkPAID" =~ ^sink-[0-9]+$ ]] && sinkout="${sinkPAID#sink-}" && [[ "$onsink" != "$sinkout" ]]; then
    (( verbose )) && printf 'Moving ffplay input %s to sink %s\n' "$sinkin" "$sinkout"
    (( sinkin )) && pactl move-sink-input "$sinkin" "${sinkout}" ||
      { printf '[ERROR] Unable to move PulseAudio input to desired output because no valid input sink was found.\n'
        printf '        Value of $sinkin=%s\n' "$sinkin"
        printf '        (or the pactl move-sink-input command failed for other reasons...)\n'; }
  elif [[ "$onsink" != "$sinkPAID" && ! "$sinkPAID" =~ ^sink-[0-9]+$ ]]; then
      printf '[ERROR] Unable to move PulseAudio input to desired output because no valid output sink was found.\n'
      printf '        Value of $sinkout=%s\n' "$sinkout"
  fi
fi

{
  printf 'choosesink="%s"\n'   "${choosesink:=0}"
  printf 'sinkin="%s"\n'        "${sinkin:=null}"
  printf 'onsink="%s"\n'        "${onsink:=null}"
  printf 'sinkout="%s"\n'      "${sinkout:=null}"
  printf 'sinkMAC="%s"\n'      "${sinkMAC:=null}"
  printf 'sinkname="%s"\n'    "${sinkname:=null@Q}"
  printf 'sinkPAID="%s"\n'    "${sinkPAID:=null}"
  printf 'ffplaypid="%s"\n'  "${ffplaypid:=null}"
} >> "$mpdzmqvarf"



(( verbose==2 )) && printf btctlout\:\ %s\\n "${btctlout[@]}"

(( verbose==2 )) && printf 'before wait: connected = %s\n' "$connected"

wait #for the output of startautossh() & startffplay() and then display it.

if (( verbose )); then printf '%s\n\n%s' "${startautosshout[@]}" "${startffplayout}"; fi

# Start a new detached screen session named "mpd.zmq" running ffplay
# screen -dmS mpd.zmq ffplay -nodisp zmq:tcp://localhost:5555 -loglevel debug

if (( verbose )); then
  printf '%s%sAn autossh/ssh should be running a tunnel on screen to %s on %s which ffplay is using:%s \n' \
    "${yellow}" \
    "${bold}" \
    "$mpdhost" \
    "$tunport" \
    "$tput0"
  hr
  mpdhost1="[${mpdhost:0:1}]${mpdhost:1}"
#  ps aux|grep --color=never "[${tunport:0:1}]${tunport:1}"|grep --color=always -E autossh\|ffplay\|"$mpdhost" ||
#  ps aux|grep --color=always [a]utossh
	  (( verbose )) &&
    { printf -- 'Tunnel status (ss -tlnp):\n%s\n\n' "$(ss -tlnp | grep --color=always -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]{1,2}\){2}")"
      if screenout="$(screen -ls mpd.zmq)"; then
        printf %s\\n%s\\n%s\\n "$blue" "$screenout" "$tput0"
      else
        printf '[%sError%s] %sNo screen for mpd.zmq found!%s\n%s%s\n' "$red" "$tput0" "$yellow" "$red" "$tput0"
      fi
      printf %s\\n
 #     psaux 5555
      psaux ffplay || psaux autossh
    }
  hr

 \sleep 1.25s
  printf '\n%s%sProcess pid info:%s\n' "$bold" "$yellow" "$tput0"
  hr
  printf %s\ %s\\n "$autosshpid" "$(cat "$autosshpid")"
 \sleep 1.25s
  printf \\n%s\ %s\\n "$ffplaypidf" "$(cat "$ffplaypidf")"
  hr
# [[ "$connected" = no ]] && btctlout="$btctlout $({ bluetoothctl list; bluetoothctl info; }|grep -E 'Controller|Device|Name:|Paired:|Connected:')"
# btctlout="$btctlout $(echo; bluetoothctl info)"

  printf \\n%s%sBluetooth\/sink\ device%s\ %s%s\/%s%s\:%s\\n \
    "$bold" \
    "$yellow" \
    "$tput0" \
    "$blue" \
    "$sinkname" \
    "${sinkMAC:-$sinkPAID}" \
    "$yellow" \
    "$tput0"
  hr

patterns=(
  'Controller'
  'Attempting'
  'Connection'
  'not available'
#  "$sinkID"
  'Device'
  'Name:'
  'Paired:'
  'Connected:'
  'PulseAudio sink'
  'Channels:'
  'Volumes:'
  'Default'
  'Sink ID:'
  'Sink codec:'
  'Sink codec description:'
)

printf %s\\n "${btctlout[@]}" |
#  GREP_COLORS='mt=1;33' \
#  GREP_COLORS='mt=01;38;5;33' \
#  GREP_COLORS='mt=38;5;33' \
  grep --color=always -Ei "$(IFS='|'; echo "${patterns[*]}")"
  hr
#  printf %s\\n "${btctlout[@]%,}"|grep --color=always -Ei 'Controller|Attempting|Connection|not available|"$sinkID"|Device|Name:|Paired:|Connected:|PulseAudio sink|Channels:|Volumes:|Default|Sink ID:|Sink codec:|Sink codec description:'
  (( verbose == 2 )) && printf ' $sinkname = %s\n' "$sinkname"
  (( verbose == 2 )) && printf '  $sinkMAC = %s\n' "$sinkMAC"
  (( verbose == 2 )) && printf ' $sinkPAID = %s\n' "$sinkPAID"
  (( verbose == 2 )) && printf '$connected = %s\n' "$connected"

  hr

####

 \sleep 1s
  printf '\n%s%sMPD enable fmpeg/zmq output:%s\n' "$bold" "$yellow" "$tput0"
  hr
  printf %s\\n "$(echo "$enableout"|grep --color=always ffmpeg\/zmq)"
  hr
 \sleep 1s
#  printf '\n%s%sPlay mpd: %s' "$bold" "$yellow" "$tput0"
#  printf %s\\n\\n "$playout"
fi

printf '\n%s%sPlay mpd: %s' "$bold" "$yellow" "$tput0"
printf %s\\n\\n "$playout"



rm -rf "$tmpdir"

exit
