#!/bin/bash
#export LC_CTYPE="UTF-8"
export TERM

#editscript(){
#  local scriptpath script path swp; scriptpath=$(realpath "$0" 2>/dev/null); script="${scriptpath##*/}"; path="${scriptpath%/*}"; swp="$path/.$script.swp"
#     [[ ! -e "$swp" ]] && printf "\n\n%s\n\n" "$swp" && (/usr/bin/nano "$scriptpath") && exit
#     printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptpath" "$swp"; exit ;}
#
#[[ "$1" = @(edit|e|-e) ]] && editscript && exit

. /usr/local/bin/editscript
. mpdignore.functions

[[ "$mpdhost" = "$(hostname)" ]] && exit 1

      bold="$(tput bold)"
     tput0="$(tput sgr0)"
    yellow="$(tput setaf 214)"
      blue="$(tput setaf 33)"
   boldred="$(tput bold setaf 9)"
   verbose=0
   tunport="$mpdzmqtunport"
   retport="$mpdzmqretport"
autosshpid="/tmp/autossh_${tunport}.pid"
 ffplaypid="/tmp/ffplayzmq-$(date -Im).pid"
  sinkID00='00:42:79:D9:B6:AF'
sinkname00='JBL Xtreme 2'
  sinkID01='00:1F:47:9F:8C:57'
sinkname01='LG SOUND BAR'
  sinkID02='C8:2B:6B:49:A6:A3'
sinkname02='JBL TUNE510BT'
  sinkID03='sink-59'
sinkname03='Built-in Audio Analog Stero'

mksinkarray(){
  ## this function creates an assoc. array of [sinkname]=sinkID pairs
  local s namevar macvar                       ## declare function locals
  declare -gA sinkarray                        ## declare global assoc. array
  declare -ga sinkorder                        ## declare global indexed array
  for s in $(compgen -A variable); do          ## do not quote shell substitution or it won't work!
    if [[ "$s" = sinkname[0-9][0-9] ]]; then   ## up to 100 sink pairs ∴ zeropad var names
      sinkorder+=("${!s}")
      n="${s#sinkname}"                      ## strip prefix to get 01, 02, etc.
      IDvar="sinkID$n"
      sinkarray["${!s}"]="${!IDvar}"        ## array additions; s=sinkname??
    fi
  done
}

pause(){ echo "$@" ; read -rp "contents" < /dev/tty; }

showhelp(){
cat <<EOF
Usage: $0 [OPTIONS]

A script for controlling various media and remote actions.

Options:
  -e, e, edit            Edit the script and exit.
  --ip <remote_ip>       Specify the remote IP for ZMQ communications.
  --port, -p <port>      Specify the remote port for ZMQ communications.
  --reset, --restart     Reset or restart the ZMQ service.
  -v, --verbose          Enable verbose output.
  --quit, --exit,        Stop the media player and tunnel; optionally...
  q[uit], exit              ...pause mpd and disconnect BT speaker.
  pause                  Pause the media playback.
  play                   Resume the media playback.
  -h, --help, help       Display this help information.
EOF
}

hr(){
  local width="$(tput cols)"
#  local width=${1:-${COLUMNS:-80}}  # Default to 80 if COLUMNS is unset
#  printf -- '%.0s—' $(seq "${1:-$COLUMNS}"); echo; }
  printf -- '%.0s—' $(seq 1 "$width"); echo; }

resetzmq(){
  btctlout="$(bluetoothctl disconnect "$sinkID00"|grep -v "Attempting to disconnect from $sinkID00")"
  printf '\n%s%sAttempting to disconnect %s%s/%s%s:%s\n%s\n' \
    "$yellow" \
    "$bold" \
    "$blue" \
    "$sinkname00" \
    "$sinkID00" \
    "$yellow" \
    "$tput0" \
    "$btctlout"
  printf %s\\n "$(hr)"

  echo
  before=before
  for j in psaux pkill psaux; do
    printf %s%s "$bold" "$yellow"
    [[ "$j" = psaux ]] && echo "$j $before:" || echo "$j:"
    printf %s "$tput0"
    for i in autossh ffplay bin/mpd.zmq; do
      "$j" "$i"|grep -v -- '--reset'
    done
    [[ "$before" = before ]] && before=after
    hr
    echo
  done
  pause "${yellow}${bold}^C to exit, [Enter] to continue.${tput0}"
  hr
}


startautossh(){
  local verbose
# if ! ps aux | grep "[a]utossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}" > /dev/null; then   #moving from ps aux to ss:
# if ! ssout=( ss -tlnp | grep -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]\)\)" ); then
# if ! ssout=( "$(ss -tlnp | grep --color=always -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]\)\)")" ); then

if ! ssout=( "$(ss -tlnp | grep --color=always -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]{1,2}\){2}")" ); then
# more permissive:  if ! ss -tlnp | grep -E "LISTEN.+:${tunport}.*users:\(.*(ssh|autossh)"; then
# pause "going to start a new connection!!!!!!!!!!!!!!! ok?  hit enter to continue"
  autoarr=(autossh -fvN -M0 -L "${tunport}:localhost:${tunport}" "$mpdhost" -p "${sshport}")
  "${autoarr[@]}"; ec="$?" #; pause "error code from autossh: $ec"
  if ! (( ec )); then { printf '%s[ERROR]%s unable to open the tunnel\nexit 1' "${boldred}" "$tput0"; exit 1; exit 1; }; fi
  \sleep 1
  autossh_pid=$(pgrep -f "autossh/autossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}")
  echo "$autossh_pid" > "${autosshpid}"  #this might be the right pid?
else
  sshpid="${ssout#*pid=}"; sshpid="${sshpid%%,*}"
  printf 'The script using an established autossh connection on PID %s:\n  %s' "$sshpid" "$(ps -fp "$sshpid")" > "${autosshpid}"
  (( verbose )) &&
    { printf -- 'tunnel status:\n  ss -tlnp\n%s\n\n' "${ssout[@]}"
      screen -ls
      psaux 5555
      psaux ffplay
    }
fi


#
#Purpose of -f in autossh
#-f (fork): This flag causes autossh to fork into the background, which is often desirable if you don't want your terminal to stay tied to the process. It makes the SSH connection run in the background, so the user can continue using the terminal for other tasks. This is useful when you're scripting or need a long-running SSH session without blocking the shell.
#Why Remove -f in My Suggestion?
#When -f is used, the parent shell forks first, then autossh forks and detaches into the background. As a result, the PID you capture using $! is of the shell's child process, not the final autossh process. That's why I initially suggested removing -f, as it allows you to more reliably capture the correct autossh PID.
#
#Compensation for Removing -f:
#By removing -f, you're preventing autossh from forking into the background. To compensate for this, I added & at the end of the command:
#
#bash
#Copy code
#autossh -vN -M0 -L"${tunport}":localhost:"${tunport}" -R"${retport}":localhost:22 "${mpdhost}" -p"${sshport}" &
#This & ensures that the command runs in the background, but without the double-forking behavior that the -f flag triggers. This allows you to capture the correct autossh PID using pgrep.
#
#If You Still Want to Use -f:
#If you absolutely need the -f flag (for instance, if the behavior of autossh requires it to double-fork and detach), you can keep it, but capturing the PID becomes trickier. You'll have to rely on pgrep or ps after the process has forked into the background.
#
#Here’s how you can still use -f and capture the correct PID:
#
#bash
#Copy code
#startssh() {
#  if ! ps aux | grep "[a]utossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}" > /dev/null; then
#    autossh -fvN -M0 -L"${tunport}":localhost:"${tunport}" -R"${retport}":localhost:22 "${mpdhost}" -p"${sshport}"
#    sleep 1  # Give autossh some time to fork and start
#    autossh_pid=$(pgrep -f "autossh.*-L${tunport}:localhost:${tunport}.*${mpdhost}.*-p${sshport}")
#    echo "${autossh_pid}" > "${autosshpid}"
#  fi
#}
#Why This Works:
#-f is still there, so autossh will run in the background just as before.
#pgrep finds the correct autossh process after it forks, using the command-line pattern to match the process.
#This method keeps the original background behavior while ensuring you capture the right PID.
}

startffplay(){
  readarray -t rmpidout < <(rm /tmp/ffplayzmq-????-??-??T??\:??-0{4,5}\:00.pid 2>&1)

  for line in "${rmpidout[@]}"; do
    if [[ "$line" != "rm: cannot remove '/tmp/ffplayzmq-"????\-??\-??\T??\:??\-\0?":00.pid': No such file or directory" ]]; then
      echo "$line"
#   else
#     printf suppressed\ error\:\ %s\\n "${rmpidout[@]}"
    fi
  done

  screen -dmS mpd.zmq sh -c \
    'ffplay -protocol_whitelist "file,rtp,udp,zmq,tcp" -autoexit -nodisp zmq:tcp://localhost:5555 -loglevel debug & echo $! > "$0"; wait' \
    "${ffplaypid}"
}
##--> startffplay() <--###############################################################################

stopffplay(){
  local screenls found
  (( verbose )) && { printf '%sLooking for open mpd.zmq screens...\n%s' "$yellow" "$tput0"; hr; }
  while screenls="$(screen -ls | grep -E '[[:digit:]]+\.mpd\.zmq')"; do
    (( verbose )) && printf 'Resetting matching screen:\n%s\n' "$screenls"
    screen -S mpd.zmq -X quit &>/dev/null
    screen -wipe &>/dev/null
    found=1
  done
  [[ ! "$screenls" ]] && (( verbose && ! found )) && printf 'No matching screens found.\n'
  (( verbose )) && hr
}
##--> stopffplay() <--################################################################################


confirm(){
  local ans IFS=
  while read -rp "$1" -n1 ans; do
    printf '\n'
    case "$ans" in
      [Yy]) return 0;;
      [Nn]) return 1;;
    esac
  done
}
##--> confirm() <--###################################################################################

stopmpdzmq(){
  local stopautossh=false
  local stopzmqscreen=false
  local nine ffplaypid ffnine
  while ! "$stopautossh" || ! "$stopzmqscreen" ; do
    stopffplay
    local autossh_pid="$(cat "$autosshpid")"
    if (( autossh_pid )) 2>/dev/null; then
      killcmd=( kill )
      [[ "$nine" ]] && killcmd+=( "$nine" )
      killcmd+=( "$autossh_pid" )
      "${killcmd[@]}"
      echo
    fi
    screenlsout="$(screen -ls|grep --color=always mpd.zmq)"
    if [[ "$screenlsout" && ! "$stopzmqscreen" ]]; then
      if [[ "$ffplaypid" ]]; then
        ffkillcmd=( kill )
        [[ "$ffnine" ]] && ffkillcmd+=( "$ffnine" )
        ffkillcmd+=( "$ffplaypid" )
        "${ffkillcmd[@]}"
        ffnine='-9'
      fi
      printf '%s%sThe output of `screen -ls|grep mpd.zmq` should be empty: \n%s' "$bold" "$yellow" "$tput0"
      hr
      echo "$screenlsout"
      hr
      echo
      confirm "Are the mpd.zmq screens closed? " && stopzmqscreen=true
      ffplaypidfile=( /tmp/ffplayzmq-*.pid )
      ffplaypid=$(< "${ffplaypid[-1]}" )
    else
      printf '%s%sThe ffplay and the mpd.zmq screen are closed.\n%s' "$bold" "$yellow" "$tput0"
      hr
      stopzmqscreen=true
    fi
    psaux5555="$(ps aux|grep --color=never "[${tunport:0:1}]${tunport:1}"|grep --color=always -E autossh\|ffplay\|"$mpdhost")"
    if [[ "$psaux5555" && ! "$stopautossh" ]]; then
      printf 'The output of `psaux 5555` should be empty: \n'
      hr
      echo "$psaux5555"
      hr
      echo
      confirm "${yellow}${bold}Are ffplay and autossh closed? $tput0" && stopautossh=true
      nine='-9'
    else
      printf '%s%s\nThe autossh tunnel is closed.\n%s' "$bold" "$yellow" "$tput0"
      hr
      stopautossh=true
    fi
  done

  echo

  ## someday this will need to be addressed with a temp file!

  if confirm "${yellow}${bold}Disconnect bluetooth speaker $sinkname00? $tput0"; then
    echo
    btctlout="$(bluetoothctl disconnect "$sinkID00")"
    printf "$btctlout"|grep --color=always -E Attempting\ to\ disconnect\ from\ "$sinkID00"\|Successful\ disconnected
    echo
  fi

  echo
  confirm "${yellow}${bold}Pause mpd on $mpdhost? $tput0" && mpctitle pause
  hr
  rm -- "${ffplaypidfile[@]}" 2>/dev/null || rm -f -- /tmp/ffplayzmq-*.pid
  rm -f -- /tmp/autossh_5555.pid
  ## won't work because glob does not expand:  rm -- "${ffplaypidfile[@]:-/tmp/ffplayzmq-*.pid}"

}
##--> stopmpdzmq() <--###################################################################################

connectBT(){
  local btctlout=("$(bluetoothctl list)")
#debug output
#  echo "btctlout+=(\"$(bluetoothctl connect \"$sinkID00\" 2>&1)\") &&"
  btctlout+=("$(bluetoothctl connect "$sinkID00" 2>&1)") &&
    connected=yes || connected=no
#debug output
#  echo "btctlout+=(\"$(bluetoothctl info "$sinkID00")\")"
  btctlout+=("$(bluetoothctl info "$sinkID00")")
#debug output
#  printf %s\\n%s\\n\\n "$connected" "$(declare -p btctlout)"

# this had to be added because the echo > fifo is blocking and the command will not complete until there's a reader, but that's not going to happen:

  tail -f "$btctlfifo" > /dev/null &
  readerpid=$!
  { echo "$connected"
    declare -p btctlout
  } > "$btctlfifo"

#debug output
 printf '\n\nExiting function %s (exit %s)' "$FUNCNAME" "$?"
# kill "$readerpid"
}

connectBT(){
  local connected verbose=0
  for s in "${sinkorder[@]}"; do
    ID="${sinkarray[$s]}"
    if [[ "$ID" =~ ^[A-F0-9]{2}(:[A-F0-9]{2}){5} ]]; then
      (( verbose )) && printf 'Attempting to connect to BT device %s...\n' "$s"
      btctlout=("$(bluetoothctl list)")
      (( verbose )) && printf 'btctlout=("$(bluetoothctl list)")\n'
      (( verbose )) && printf 'btctlout=("%s")\n' "$(bluetoothctl list)"
      btctlout+=("$(bluetoothctl connect "$ID" 2>&1)") &&
        connected=yes || connected=no
      (( verbose )) && printf 'btctlout+=("$(bluetoothctl connect "$sinkID00" 2>&1)") &&\n  connected=yes || connected=no\n'
      (( verbose )) && printf 'btctlout+=("%s") &&\n' "$(bluetoothctl connect "$ID" 2>&1)"
      (( verbose )) && printf 'connected=%s\n' "$connected"
      btctlout+=("$(bluetoothctl info "$ID")")
      (( verbose )) && printf 'btctlout+=("$(bluetoothctl info "$sinkID00")")\n'
      (( verbose )) && printf 'btctlout+=("%s")\n' "$(bluetoothctl info "$ID")"
      (( verbose )) && printf '\n\nconnected=%s\n' "$connected"
      (( verbose )) && printf %s\\n "${btctlout[@]}"
      (( verbose )) && printf \\n
      if [[ "$connected" = yes ]]; then
        (( verbose )) && printf 'BLUETOOTH DEVICE %s CONNECTED!\n' "$s"
        sinkname="$s"
        sinkMAC="$ID"
        sinkPAID="$(pulsemixer --list-sinks|awk -v sn="$sinkname" '$0 ~ sn {sub(/,$/,"",$3); print $3}')"
        (( verbose )) && printf ' $sinkname = %s\n' "$sinkname"
        (( verbose )) && printf '  $sinkMAC = %s\n' "$sinkMAC"
        (( verbose )) && printf ' $sinkPAID = %s\n' "$sinkPAID"
        (( verbose )) && printf '$connected = %s\n' "$connected"
        break
      fi
    fi
  done

# this had to be added because the echo > fifo is blocking and the command will not complete until there's a reader, but that's not going to happen:

 # tail -f "$btctlfifo" > /dev/null &
 # readerpid=$!
#  { echo "$connected"
#    declare -p btctlout
#  } > "$btctlfifo"
  { declare -p connected sinkname sinkMAC sinkPAID
    declare -p btctlout
  } > "$btctlfifo"
  ret="$?"

 (( verbose==2 )) && printf '%s\\n' "${btctlout[@]}"
 (( verbose==2 )) && declare -p btctlout

 printf '\n\nExiting function %s (return %s)\n' "$FUNCNAME" "$ret"
 return "$ret"
# kill "$readerpid"
}


remote-zmq(){
  local zmqport
  local remote="$1"; shift
  [[ "$1" = -@(-port|p) ]] && zmqport="$2"; shift 2
  sshargs=( 'ssh' )
  sshargs+=( '-t' )
  [[ "$zmqport" ]] && sshargs+=( "-p$zmqport" )
  sshargs+=( '--' )
  sshargs+=( "$remote" )
  sshargs+=( 'mpd.zmq' )
  sshargs+=( "$@" )
# ssh -t "$remote" mpd.zmq "$@"
# ssh $(printf %s\  "${sshargs[@]}")
  "${sshargs[@]}"
  exit "$?"
}

############################################################################################################
# mpd.zmq main block
############################################################################################################

while (( "$#" )); do
  [[ "$1" =  @(--help|-h|help) ]] && { showhelp; shift; exit; }
  [[ "$1" =             --port ]] && { port="$2"; remote-zmq "$remote" "$@"; shift 2; continue; }
  [[ "$1" =               --ip ]] && { remote="$2"; remote-zmq "$remote" "$@"; shift 2; continue; }
  [[ "$1" = --@(reset|restart) ]] && { resetzmq; shift; continue; }
  [[ "$1" =    @(--verbose|-v) ]] && { verbose=1; shift; continue; }
  [[ "$1" = @(--quit|q@(|uit)) ]] && { stopmpdzmq; exit; }
  [[ "$1" =              pause ]] && { pkill -19 ffplay; exit; }  # -SIGSTOP
  [[ "$1" =               play ]] && { pkill -18 ffplay; exit; }   # -SIGCONT
  [[ "$1" = @(--choose|--sink) ]] && { choosesink=1; shift; continue; }
done

mksinkarray                                     ## call function to create the sink array

if (( choosesink )); then
  printf \\n
  sinknamesel="$(gum choose --header="Choose a bluetooth device/sink from list:" "${sinkorder[@]}")" ||
   { printf 'User aborted. (exit 130)\n' ; exit 130; }
  sinksel="${sinkarray[$sinknamesel]}"
  printf 'Bluetooth/sink device %s = %s chosen.\n' "$sinknamesel" "$sinksel"
  read -rp "Any key to continue (Control-C exits)..."
  sinkorder=( "$sinknamesel" )
fi

(( verbose )) && printf '\nCreating btctlfifo with mkfifo...\n'
tmpdir=$(mktemp -d)
btctlfifo=$(mktemp -u "$tmpdir/fifo_XXXX")
mkfifo "$btctlfifo"
(( verbose )) && printf '  btctlfifo=%s\n' "$btctlfifo"

## instead of looking just for the BT connections, we should go through the sinks in order of what is in the mpd.zmq.conf file but we'll need to determine if they're known BT sinks.  this will be obviated by selecting a sink first, but then that requires user input to guide it.

## this for loop will look to see if any of the BT devices (as determined by if 'sinkID??' is a MAC address)
##  are connected, in order of sinkarray[@]

printf '\n%sChecking for a connected Bluetooth device or PulseAudio sink...\n%s' "$yellow" "$tput0"
for s in "${sinkorder[@]}"; do
  ID="${sinkarray[$s]}"
  if [[ "$ID" =~ ^[A-F0-9]{2}(:[A-F0-9]{2}){5} ]]; then
#    printf 'Checking %s for BT connection... ' "$s"
    connected=$(bluetoothctl info "$ID"|awk '$1=="Connected:" {print $2}')
    if [[ "$connected" = yes ]]; then
      printf '  %s%s%s connected!\n' "$blue" "$s" "$tput0"
      sinkname="$s"
      sinkMAC="$ID"
      sinkPAID="$(pulsemixer --list-sinks|awk -v sn="$sinkname" '$0 ~ sn {sub(/,$/,"",$3); print $3}')"
      (( verbose )) && printf '  $sinkname = %s\n' "$sinkname"
      (( verbose )) && printf '   $sinkMAC = %s\n' "$sinkMAC"
      (( verbose )) && printf '  $sinkPAID = %s\n' "$sinkPAID"
      (( verbose )) && printf ' $connected = %s\n' "$connected"
      break
    else
      printf '  %s not connected.\n' "$s"
    fi
  elif [[ "$ID" =~ ^sink-[0-9]+$ ]]; then
    pulsemixer --list-sinks |\grep -q "$ID" &&
      connected='yes' || connected='no'
    ! (( verbose )) && printf 'Device chosen is a non-Bluetooth PulseAudio sink.\n'
    sinkname="$s"
    unset sinkMAC
    sinkPAID="$ID"
    [[ "$connected" = yes ]] && printf '\nPulseAudio sink connected: %s = %s\n' "$sinkname" "$sinkPAID"
    [[ "$connected" = no ]] && { printf 'Invalid pulse sink selected. Investigate. (exit 1)\n'; exit 1; }
    (( verbose )) && printf ' $sinkname = %s\n' "$sinkname"
    (( verbose )) && printf '  $sinkMAC = %s\n' "$sinkMAC"
    (( verbose )) && printf ' $sinkPAID = %s\n' "$sinkPAID"
    (( verbose )) && printf '$connected = %s\n' "$connected"
  fi
done

printf \\n


if [[ "$connected" = no && "$sinkMAC" ]]; then
  connectBT&
## moving these till after the wait below
#  IFS= read -r connected < "$btctlfifo"  # this should grab just one line (no while)
#  . "$btctlfifo" # rest of FIFO
elif (( verbose )) && [[ "$sinkMAC" ]]; then
#  echo "entered else portion... are you stuck?"
#  btctlout="$(echo "$sinkname/$sinkID was already connected."; bluetoothctl list; bluetoothctl info "$sinkID")"
  btctlout=( "$sinkname00/$sinkMAC was already connected." "$(bluetoothctl list)" "$(bluetoothctl info $sinkID)" )
  printf %s\\n "${btctlout[@]}"
elif (( verbose == 2 )) && [[ ! "$sinkMAC" ]]; then
  printf 'In the if block to connectBT() but this is a non-BT device.\n\n'
fi

(( verbose )) && printf '%sCheck/start autossh...%s\n\n' "$yellow" "$tput0"
startautosshout=( "$(startautossh&)" )

#pause "$(printf '%srestarting ffplay screen%s\n\n' "$bold" "$tput0")"
#pause "${bold}restarting ffplay screen$tput0"
stopffplay

if (( verbose )); then
  screenout=$(screen -ls)
  printf '\n%s%sNo mpd.zmq screens should be open:%s \n%s%s' "$yellow" "$bold" "$tput0" "$(hr)" "$screenout"
  printf %s\\n "$(hr)"
fi
#fg >/dev/null

startffplayout=( "$(startffplay&)" )

zmqoutput="$(mpcp outputs|\grep ffmpeg\/zmq|awk '{print $2}')"
enableout=$(mpcp enable "$zmqoutput")
#(( verbose )) && printf '$enableout = %s\n' "$enableout"
playout=$(verbose=0 mpctitle play 2>/dev/null)
#(( verbose )) && printf '$playout = %s\n' "$playout"
pulsemixer --unmute

(( verbose==2 )) && printf 'before if: connected = %s\n' "$connected"

if [[ "$connected" = no && "$sinkMAC" != 'pulsesink' ]]; then
  printf 'Reading from %s...\n' "$btctlfifo"
#  IFS= read -r connected < "$btctlfifo"  # this should grab just one line (no while)
  . "$btctlfifo" # rest of FIFO
#  kill "$readerpid"
elif [[ ! "$sinkMAC" ]]; then
  btctlout=( "PulseAudio sink:" )
  readarray -d, arr < <( pulsemixer --list-sinks|\grep "$sinkPAID" )
  for (( i=0; i<=${#arr[@]}; i++)); do
    if ! (( i )); then
      btctlout+=( " Sink ID: ${arr[$i]#*ID: }" )
      :
    elif [[ "${arr[$i]}" != \ Volumes* ]]; then
      btctlout+=( "${arr[$i]}" )
    else
      btctlout+=( "${arr[$i]}${arr[$i+1]}" )
      (( i++ ))
    fi
  done

fi

(( verbose==2 )) && printf btctlout\:\ %s\\n "${btctlout[@]}"

(( verbose==2 )) && printf 'before wait: connected = %s\n' "$connected"

wait #for the output of startautossh() & startffplay() and then display it.

if (( verbose )); then printf '%s\n\n%s' "${startautosshout[@]}" "${startffplayout}"; fi

# Start a new detached screen session named "mpd.zmq" running ffplay
# screen -dmS mpd.zmq ffplay -nodisp zmq:tcp://localhost:5555 -loglevel debug

if (( verbose )); then
  printf '%s%sAn autossh/ssh should be running a tunnel on screen to %s on %s which ffplay is using:%s \n' \
    "${yellow}" \
    "${bold}" \
    "$mpdhost" \
    "$tunport" \
    "$tput0"
  hr
  mpdhost1="[${mpdhost:0:1}]${mpdhost:1}"
#  ps aux|grep --color=never "[${tunport:0:1}]${tunport:1}"|grep --color=always -E autossh\|ffplay\|"$mpdhost" ||
#  ps aux|grep --color=always [a]utossh
	  (( verbose )) &&
    { printf -- 'Tunnel status (ss -tlnp):\n%s\n\n' "$(ss -tlnp | grep --color=always -E "LISTEN.+:${tunport}.*users:\(\(\"(ssh|autossh)\",pid=[[:digit:]]+,fd=[[:digit:]]{1,2}\){2}")"
      screen -ls|grep -E There\ is\ a\ screen\ on\|mpd.zmq\|Socket\ in
      printf %s\\n
 #     psaux 5555
      psaux ffplay || psaux autossh
    }


 \sleep 1.25s
  printf '\n%s%sProcess pid info:%s\n' "$bold" "$yellow" "$tput0"
  hr
  printf %s\ %s\\n "$autosshpid" "$(cat "$autosshpid")"
 \sleep 1.25s
  printf \\n%s\ %s\\n "$ffplaypid" "$(cat "$ffplaypid")"
# [[ "$connected" = no ]] && btctlout="$btctlout $({ bluetoothctl list; bluetoothctl info; }|grep -E 'Controller|Device|Name:|Paired:|Connected:')"
# btctlout="$btctlout $(echo; bluetoothctl info)"

  printf \\n%s%sBluetooth\/sink\ device%s\ %s%s\/%s%s\:%s\\n \
    "$bold" \
    "$yellow" \
    "$tput0" \
    "$blue" \
    "$sinkname" \
    "${sinkMAC:-$sinkPAID}" \
    "$yellow" \
    "$tput0"
  hr
####
  printf %s\\n "${btctlout[@]%,}"|grep --color=always -Ei 'Controller|Attempting|Connection|not\ available|"$sinkID"|Device|Name:|Paired:|Connected:|PulseAudio sink|Channels:|Volumes:|Default|Sink ID:'

####

 \sleep 1s
  printf '\n%s%sMPD enable fmpeg/zmq output:%s\n' "$bold" "$yellow" "$tput0"
  hr
  printf %s\\n "$(echo "$enableout"|grep --color=always ffmpeg\/zmq)"
 \sleep 1s
#  printf '\n%s%sPlay mpd: %s' "$bold" "$yellow" "$tput0"
#  printf %s\\n\\n "$playout"
fi

printf '\n%s%sPlay mpd: %s' "$bold" "$yellow" "$tput0"
printf %s\\n\\n "$playout"



rm -rf "$tmpdir"

exit
