#!/bin/bash
## probably should source confirm up here.  --> confirm's being used as a script from /usr/local//bin
#verbose=1
. mpdignore.functions

shopt -s extglob nullglob

pidfile='/tmp/mpdlinger.pid'
cmdfile='/tmp/mpdlinger.cmd'
countfile='/tmp/mpdlinger.count'

#verbose=1

{ (( verbose )) || [[ "$1" != --exec ]] ; } && printf '%s has started.\n' "$0"
(( verbose )) && printf '\n           0 = %s\n   prevlimit = %s\n  blocklimit = %s\n       limit = %s\n       count = %s\n          $* = %s\n\n' "$0" "$prevlimit" "$blocklimit" "$limit" "$count" "$*"

# Signal traps
## If you want the variables like $count and $(...) to be evaluated when the trap is triggered, not when it's defined, you should use single quotes.
trap sigint SIGINT
trap '[[ -f "$countfile" ]] && count=$(< "$countfile"); { (( verbose )) && echo "Count updated to: $count"; }' USR1
#trap 'pkill mpc; pkill -g $mpdlingerpid lolcat; ipchandler' USR2
#trap 'pkill mpc; pkill -g $pgid lolcat; ipchandler' USR2
trap '
  [[ ! "$pgid" ]] && pgid=$(ps -o pgid= -p "$mpdlingerpid" | tr -d " ")
  pkill -g "$pgid" mpc
  pkill -g "$pgid" lolcat
  ipchandler
' USR2

startupcheck(){
  (( verbose )) && printf 'In %s.\n' "${FUNCNAME[0]}"

## first determine if there's an ipc command passed

if [[ " ${ipcargs[*]} " = *" $1 "* ]]; then
  ipccmd="$1"
  shift
  [[ "$1" =~ ^[0-9]+$ ]] && ipcval="$1" && shift

  if (( $# )); then
    printf 'The IPC wrapper accepts EXACTLY ONE of the following cli arguments:\n%s\nThe following will be ignored:\n %s\n' "$(IFS=\|; printf '%s' "${ipcargs[*]}")" "$*"
    set --
  elif [[ " ${ipc1args[*]} " = *" $ipccmd " ]] && [[ "$ipcval" ]]; then
    printf 'These IPC wrapper commands do not accept numeric arguments:\n%s\nThe following will be ignored:\n %s\n' "$(IFS=\|; printf '%s' "${ipc1args[*]}")" "$ipcval"
    unset ipcval
  elif [[ " ${ipc2args[*]} " = *" $ipccmd " ]] && [[ ! "$ipcval" ]]; then
    printf 'These IPC wrapper commands require a numeric argument:\n%s' "$(IFS=\|; printf '%s' "${ipc2args[*]}")"
    exit 1
  fi

  printf '%s%s\n' "$ipccmd" "${ipcval:+ $ipcval}" > "$cmdfile"

## run balance of startupcheck() after validating the ipc commands to get "$mpdlingerpid"
#  startupcheck "ipc"
  ipc=1

fi






  ## if pidfile exists, check if pid still running; if stale remove pidfile and unset mpdlingerpid
  if [[ -f "$pidfile" ]]; then
    mpdlingerpid="$(< "$pidfile")"
    (( verbose )) && read -rp "$mpdlingerpid"
    if ! ps -p "$mpdlingerpid" > /dev/null; then
      printf 'Stale pidfile found, removing: %s\n' "$pidfile"
      rm -f "$pidfile"
      unset mpdlingerpid
    else
      pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"
      export mpdlingerpid="$mpdlingerpid"
    fi
  fi

  ## if no valid pidfile found, try to find running mpdlinger processes excluding this shell and edits
  if [[ ! -f "$pidfile" ]] || [[ ! "$mpdlingerpid" ]]; then
    (( verbose )) && printf 'pid of this process: $$ = %s\n' "$$"

    readarray -t pgrepout < <(pgrep mpdlinger -a | grep -Ev -- "$$|--edit")

    ## get our process group id for comparison
    pgid2=$(ps -o pgid= -p $$ | tr -d ' ')
    (( verbose )) && printf '%s\n' "$pgid2"

    ## filter out any pids in same pgid as us (screen or exec children)
    for i in "${pgrepout[@]}"; do
      unset pidpgid   ## make sure we're not reusing a stale value
      pid="${i%% *}"
      pidpgid=$(ps -o pgid= -p "$pid" | tr -d ' ')
      (( verbose )) && printf 'pid=%s  pidpgid=%s  ourpgid=%s  cmd=%s\n' "$pid" "$pidpgid" "$pgid2" "$i"

      ## if process is in a different pgid, assume it's an orphaned daemon
      if [[ "$pidpgid" && "$pidpgid" != "$pgid2" ]]; then
        pgreplines+=("$i")
      fi
    done

    ## show filtered lines if any
    (( verbose )) && { printf -- --\\n; printf '%s\n' "${pgreplines[@]}"; printf -- --\\n; }

    ## if we found any suspicious candidates, prompt user
    if (( ${#pgreplines[@]} )); then
      printf '\n[%sWARN%s] A pid for mpdlinger was identified without a corresponding %s!\n' "$yellow" "$tput0" "$pidfile"
      printf '[%sWARN%s] This indicates that the pidfile has been somehow misplaced...\n\n' "$yellow" "$tput0"
      ## display all the viable candidates
      printf 'Output of '\''%spgrep mpdlinger -a|grep -Ev -- "$$|--edit"%s'\'':\n' "$blue" "$tput0"
      printf '%s' "$blue"

      ## use gum if more than one line, otherwise just print
      if (( ${#pgreplines[@]} > 1 )); then
        mpdlingerpid="$(printf '%s\n' "${pgreplines[@]}" | gum choose)"
        mpdlingerpid="${mpdlingerpid%% *}"
      else
        printf '%s\n' "${pgreplines[0]}"
        mpdlingerpid="${pgreplines[0]%% *}"
      fi
      printf '%s' "$tput0"

      printf \\n

      ## prompt before writing to file, and get pgid again
      confirm -Y "${red}Write pid $mpdlingerpid to $pidfile?${tput0}" &&
        { printf '%s\n' "$mpdlingerpid" > "$pidfile"
          export mpdlingerpid="$mpdlingerpid"
          pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"; } ||
        ## bail out if confirmation fails
        { printf '\nFailed to determine a pid for the daemon. Investigate. (exit 1)\n\n'; exit 1; }
    fi
  fi

## this was the start of the old startupcheck() and shouldn't be run when an ipc command is passed
  if ! (( ipc )); then
    ## compact pids array excluding --edit processes
    readarray -t pids < <(pgrep mpdlinger)
    for i in "${!pids[@]}"; do
      (( verbose )) && printf 'i=%s\n' "$i"
      (( verbose )) && ps -p "${pids[i]}" -o command --no-header
      [[ "$(ps -p "${pids[i]}" -o command --no-header)" = *\ --edit* ]] && unset 'pids[i]'
    done
    pids=("${pids[@]}")

    (( verbose )) && printf 'Array compacted, ${#pids[@]}: %s\n' "${#pids[@]}"
    (( verbose )) && printf '${pids[@]} = %s\n' "${pids[@]}"
    (( verbose )) && printf '$mpdlingerpid = %s\n' "$mpdlingerpid"
    (( verbose )) && (( mpdlingerpid )) &&
                     printf 'ps -p %s = %s\n' "$mpdlingerpid" "$(ps -p $mpdlingerpid)"
    (( verbose )) && printf 'ls %s:\n%s\n' "$pidfile" "$(ls "$pidfile" 2>/dev/null)"
    (( verbose )) && printf 'cat %s:\n%s\n' "$pidfile" "$(cat "$pidfile" 2>/dev/null)"
    (( verbose )) && pause "Pause in ${FUNCNAME[0]}..."

    ## check if an existing mpdlinger screen session is running and try to resume it (skip if we're the same process)
    if (( mpdlingerpid )) && (( mpdlingerpid != $$ )) && ps -p "$mpdlingerpid" >/dev/null && screenpid="$(screen -ls | grep -m1 mpdlinger)"; then
      printf '\nAn instance of mpdlinger is already running in a screen process:\n%s\n' "$screenpid"
      printf '\nAttempting to resume screen...\n\n'
      (( verbose )) && read -rp 'exec screen -r "$(awk '\''{print $1}'\'' <<< "$screenpid")"'
      exec screen -r "$(awk '{print $1}' <<< "$screenpid")"
      printf 'Unable to reattach to the screen that mpdlinger is running on.\n'
      confirm -Y 'Try to reattach with "screen -x" to attempt attaching to a non-detached screen?' &&
        exec screen -r "$(awk '{print $1}' <<< "$screenpid")"
      printf 'Reattachment to screen aborted or failed.\nExiting (exit 1)\n.'
      (( verbose )) && read -rp pause\ before\ exit\ 1
      exit 1

    ## check if an mpdlinger process is running outside screen, error out so user can handle it
    elif (( mpdlingerpid )) && (( mpdlingerpid != $$ )) && ps -p "$mpdlingerpid" >/dev/null; then
      [[ "$(ps -o stat= -p "$mpdlingerpid")" = "S" ]] && background=1
      printf 'An instance of mpdlinger is already running (not in a named screen process):\n'
      ! (( background )) && printf 'You will need to chase it down in another window or kill it (pid=%s).\nExiting (exit 1)\n.' "$mpdlingerpid"
      (( background )) && printf 'You will need to chase it down somewhere in the background or kill it (pid=%s).\nExiting (exit 1)\n.' "$mpdlingerpid"
      (( verbose )) && read -rp pause\ before\ exit\ 2
      exit 1

    ## if multiple mpdlinger pids found, error out for manual cleanup
    elif (( "${#pids[@]}" > 1 )); then
      printf 'There is more than one instance of mpdlinger running:\n%s\n\n' "$(read -rp "$(pgrep mpdlinger -a)")"
      printf 'Exiting. (exit 1)'
      (( verbose )) && read -rp pause\ before\ exit\ 3
      exit 1

    ## finally, set mpdlingerpid to us and write pidfile if none of above apply
    else
      mpdlingerpid="$$"
      printf %s\\n "$mpdlingerpid" > "$pidfile"
      export mpdlingerpid="$mpdlingerpid"
   #   [[ -f "$cmdfile" ]] && rm "$cmdfile"
    fi

## in the case ipc=1, process the validaded ipccommand
## HOEWEVER, WE STILL NEED TO LAUNCH A DAEMON IF ONE DOESN'T EXIST YET!!!
## i.e., if there's no $pidfile or $mpdlingerpid and we feel that is accurate, try launching the daemon to screen.  if that fails, then exit?
  else
if [[ ! "$mpdlingerpid" ]]; then
  printf 'No running mpdlinger daemon found. Would you like to launch one in screen?'
  confirm -Y 'Launch mpdlinger now?' && {
#    screen -S mpdlinger -dm bash -c 'exec ~/bin/mpdlinger'
## maybe don't pass "$@" here?
    mpdlinger -s "$@"
    sleep 1
    if [[ -f "$pidfile" ]]; then
      mpdlingerpid="$(< "$pidfile")"
      pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"
      export mpdlingerpid pgid
    else
      printf 'Failed to launch mpdlinger daemon or pidfile not created. (exit 1)\n'
      exit 1
    fi
  } || {
    printf 'Cannot send IPC command without running daemon. (exit 1)\n'
    exit 1
  }
fi
    (( verbose )) && printf 'kill -USR2 %s\n' "$mpdlingerpid"
    [[ ! "$pgid" ]] && pgid=$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')
    kill -USR2 "$mpdlingerpid"
    pkill -g "$pgid" mpc
    pkill -g "$pgid" lolcat
    [[ "$ipccmd" = next ]] && mpctitle
    exit 0
  fi

  (( verbose )) && printf 'Leaving %s...' "${FUNCNAME[0]}"
}
##--> startupcheck() <--#######################################################################

ipchandler() {
  local cmd
  (( verbose )) && printf '\nIn ipchandler().\nContents of %s: "%s"\n\n' "$cmdfile" "$(< "$cmdfile")"

  cmd="$(head -n1 "$cmdfile" 2>/dev/null)"
  > "$cmdfile"

  [[ -z "$pgid" && -n "$mpdlingerpid" ]] && pgid=$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')
  [[ -n "$pgid" ]] && pkill -g "$pgid" lolcat

  case "$cmd" in
    pause)
      paused=1
      echo "Paused via CLI"
      exec env paused=1 mpdlinger --exec
      ;;

    resume)
      unset paused
      echo "Resumed via CLI"
      exec env mpdlinger --exec
      ;;

    quit)
      cleanupexit
      ;;

#    skip)
#      echo "Skipping song..."
#      if (( count < limit )); then
#        next >/dev/null
#        (( count++ ))
#      else
#        mpcp -q random on
#        next >/dev/null
#        mpcp -q random off
#        count=1
#      fi
#      unset blocklimit
#      (( verbose )) && pause "Resuming after skip with count=$count"
#      exec env count="$count" mpdlinger --exec
#      ;;
#
#    next)
#      mpcp -q random on
#      next >/dev/null
#      mpcp -q random off
#      (( blocklimit )) && limit="$prevlimit"
#      unset blocklimit
#      (( verbose )) && printf 'next) prevlimit=%s limit=%s\n' "$prevlimit" "$limit"
#      exec env limit="$limit" mpdlinger --exec
#      ;;

    skip)
      echo "Skipping song..."
      if (( count < limit )); then
        next >/dev/null
        (( count++ ))
      else
        mpcp -q random on
        next >/dev/null
        mpcp -q random off
        count=1
      fi
      (( verbose )) && pause "Resuming after skip with count=$count"
      exec env mpdlingerpid="$mpdlingerpid" count="$count" blocklimit="$blocklimit" limit="$limit" prevlimit="$prevlimit" mpdlinger --exec
      ;;

    next)
      mpcp -q random on
      next >/dev/null
      mpcp -q random off
      (( blocklimit )) && { limit="$prevlimit"; unset blocklimit; }
      (( verbose )) && printf 'next) prevlimit=%s limit=%s\n' "$prevlimit" "$limit"
      exec env limit="$limit" prevlimit="$prevlimit" count="$count" mpdlinger --exec
      ;;

    verbose)
      exec env verbose=1 mpdlinger --exec
      ;;

    limit\ *)
      limit="${cmd#limit }"
      echo "Limit set to $limit via CLI"
      exec env limit="$limit" mpdlinger --exec
      ;;

    count\ *)
      count="${cmd#count }"
      echo "Count set to $count via CLI"
      exec env count="$count" mpdlinger --exec
      ;;

    blocklimit\ *)
      blocklimit="${cmd#blocklimit }"
      prevlimit="${prevlimit:-$limit}"
      echo "Block limit set to $blocklimit (prev=$prevlimit)"
      exec env blocklimit="$blocklimit" prevlimit="$prevlimit" limit="$blocklimit" count="$count" verbose=1 mpdlinger --exec
      ;;

    *)
      (( verbose )) && read -rp "Fallback in ipchandler(): limit=$limit blocklimit=$blocklimit count=$count"
      exec env limit="$limit" count="$count" mpdlinger --exec
      ;;
  esac
}

##--> ipchandler() <--###########################################################################






pauseloop(){
  pauseout(){
    . <(mpd-current.py)
    printf '%s\n%s \n%s \n%s \n \n%s\n ' \
           "$(toilet -tf "$font1" "$1")" \
           "$(toilet -tf "$font1" "$artist / $title")" \
           "$(toilet -tf "$font1" "$album:")" \
           "$(toilet -tf "$font1" "${blocklimit:+Blocklimit: }$count/$limit")" \
           "$(mpctitle)" |
      "${lolargs[@]}"&
  }

  if [[ "$1" = --out ]]; then
    clear -x
    mpcp -q random off
    pauseout 'mpdlinger will pause changing artists...'
  elif [[ "$1" = --in ]]; then
    toilet -tf "$font1" "Resuming rock blocks! $limit in a row!"|"${lolargs[@]}"
    sleep 2
    unset paused
    exec mpdlinger --exec -c"$count" --off -l"$limit"
  else
    while output=( $(\mpc idle playlist player) ) && (( paused )); do
      if [[ "${output[@]}" = playlist\ player ]]; then
        clear -x
        ((count++))
        pauseout 'Paused...'
      fi
    done
  fi
}
##--> pauseloop() <--###########################################################################

sigint(){
  # Kill only child processes in the same process group
  printf 'sigint() $pgid=%s\n' "$pgid"
  printf 'sigint() $mpdlingerpid=%s\n' "$mpdlingerpid"
  [[ ! "$pgid" ]] && pgid=$(ps -o pgid= -p "$mpdlingerpid" | tr -d " ")
  pkill -g "$pgid" lolcat
#  printf \\b\\b%s\\n . . .
  printf '\r\033[K'
  if (( paused )); then
    pauseloop --in
  else
    mainmenu
  fi
}
##--> sigint() <--###############################################################################

mainmenu(){
  while true; do
    option=$(gum choose \
      --header="Multi-level Menu" \
      --height=10 \
      --item.foreground="33" \
      --cursor.foreground=214 \
      "Next block" \
      "Playlist" \
      "Change limit" \
      "Change current block limit" \
      "Pause" \
      "Log" \
      "Skip" \
      "Quit")

    case $option in
      "Next block")
#        mpcp -q random on
#        next >/dev/null
#        mpcp -q random off
#        exec mpdlinger --exec
        printf 'next' > "$cmdfile"
        ipchandler
        ;;
      "Skip")
        printf 'skip' > "$cmdfile"
        ipchandler
#        skipsong
        ;;
      "Playlist")
        playlistmenu
        ;;
      "Change limit")
#        changelimit
        read -p "Enter new limit: " limit &&
          printf "$limit" > /tmp/mpdlinger.cmd
        printf 'Limit changed to %s.\n' "limit $limit"
        ipchandler
        ;;
      "Change current block limit")
        printf 'This has not been implemented yet?\n'
        read -p "Change limit for current block to: " blocklimit &&
          printf blocklimit\ %s\\n "$blocklimit" > /tmp/mpdlinger.cmd
        printf 'Current block limit changed to %s.\n' "blocklimit $blocklimit"
        ipchandler
        ;;
      "Log")
        grep \:\ player\: /var/log/mpd/mpd.log|tail -n 40
        pause "Continue? "
        ;;
      "Pause")
        pauseloop --out
        exec mpdlinger --exec -p -c"$count" -l"$limit"
        ;;
      "Quit")
        cleanupexit
        ;;
      "")
        exec mpdlinger --exec -c"$count" -l"$limit"
        ;;
      *)
        echo "Invalid option."
        ;;
    esac
  done
}
##--> mainmenu() <--############################################################################



showhelp(){
  cat <<EOF
Usage: $0 [options]

$(hr2 "CLI IPC Wrapper")
Usage:
  mpdlinger pause              Suspends mpdlinger function
  mpdlinger resume             Resumes mpdlinger function
  mpdlinger next               Moves to the next block of songs
  mpdlinger skip               Skips currently-playing song?
  mpdlinger limit <num>        Changes the global limit to <num>
  mpdlinger blocklimit <num>   Changes the limit for current block to <num>
  mpdlinger quit               Should terminate any current mpdlinger daemons
  NOT WORKING:
  mpdlinger count <num>        Updates the count of played songs for current block to <num>

$(hr2 "CLI Launch Flags")
NB: These are probably exclusively for internal control at this point.

Options:
  -p              Pause the process.
  -v|--verbose    Verbose mode
  --off, --on     Initialize with a random value, setting the state to 'off' or 'on'.
  -c <num>        Set the count to <num>. Error if no numerical argument after -c.
  -l <num>        Set the limit to <num>. Error if no numerical argument after -l.
  -b <num>        Set the current block limit to <num>. Error if no numerical argument after -b.

Description:
  - The -p flag pauses the process.
  - The --off or --on flags initialize a random state.
  - The -c|-l|-b flags set the count|limit|blocklimit, respectively, to the specified number.

Error:
  - If -c|-l|-b are used without a valid number, an error message is displayed.

Examples:
  $(basename $0) -p                  Pauses the process.
  $(basename $0) --on                Initializes with the 'on' state.
  $(basename $0) -c 5                Sets the count to 5.
  $(basename $0) -l 10               Sets the limit to 10.
  $(basename $0) -b 6                Sets the limit for the current block to 6.
EOF
}
##--> showhelp() <--############################################################################


playlistmenu(){
  while true; do
    suboption=$(gum choose \
      --header="Playlist Menu" \
      --height=8 \
      --item.foreground="33" \
      --cursor.foreground=214 \
      "Current position" \
      "Search" \
      "Back")

    case "$suboption" in
      "Current position")
        playlist
        exec mpdlinger --exec
        ;;
      "Search")
        searchplaylist
        ;;
      ""|"Back")
        return  # Go back to the main menu
        ;;
      *)
        echo "Invalid option."
        ;;
    esac
  done
}
##--> playlistmenu() <--#######################################################################

searchplaylist(){
  term="$(gum input --placeholder=" Search term..." --prompt "Search playlist: " --cursor.foreground=214 --header.foreground=33 --prompt.foreground=33)"
  subsubopt=$(gum choose \
    --header="Search Options" \
    --height=6 \
    --item.foreground="33" \
    --cursor.foreground=214 \
    "Current playlist" \
    "Entire library" \
    "Back")

  case "$subsubopt" in
    "Current playlist")
      playlist "$term"
      exec mpdlinger --exec
      ;;
    "Entire library")
      playlist -A "$term"
      exec mpdlinger --exec
      ;;
    ""|"Back")
      return  # Go back to the previous menu
      ;;
    *)
      echo "Invalid option."
      ;;
  esac
}
##--> searchplaylist() <--#######################################################################

changelimit(){
  read -p "Enter new limit: " limit
  echo "Limit changed to $limit"
  exec mpdlinger --exec -c"$count" -l"$limit"
}
##--> changelimit() <--#######################################################################

cleanupexit(){
  echo "Exiting..."
  rm /tmp/mpdlinger "$pidfile" 2>/dev/null
  mpcp random on | grep --color=always -B2 'random\:\ on'
  exit 130
}
##--> cleanupexit() <--#######################################################################

#═══════▶ MAIN CODE ◀════════════════════════════════════════════════════════

ipcargs=(pause resume next skip quit limit count blocklimit verbose)
ipc1args=(pause resume next skip quit)
ipc2args=(limit count blocklimit)

[[ " $* " = *\ @(-h|--help|help)\ * ]] && { showhelp; exit 0; }
## --edit should be handled by the sourced editscript funciton
## uncomment if needed:
## [[ " $* " = *\ --edit\ * ]] && { editscript; exit 0; }

#[[ "$1" != @(--edit|--exec|--help|-h|help) && startupcheck "$@"

[[ "$STY" ]] && unset COLORTERM
lolargs=(lolcat)
[[ "$STY" ]] && lolargs+=(-ap 2) || lolargs+=(-tap 2)
##  -F, --freq=<f>        Rainbow frequency (default: 0.1)
##  -d, --duration=<i>    Animation duration (default: 12)
##  -s, --speed=<f>       Animation speed (default: 20.0)
lolargs+=(-d 04) #lolargs+=(-d 08)
lolargs+=(-s 15) #lolargs+=(-s 15)
lolargs+=(-F 0.075)
#fonts are in /usr/share/figlet
font1=future
font2=pagga
font2="$font1"
#filter=metal


unset initrand  #probably can remove
unset paused    #probably can remove
#limit=4
limit="${limit:-4}" #probably need to define a default limit somewhere.  should i use prevlimit though?
unset current  #probably can remove
count=1        #since i'm not zero indexed, i need to fix that before removing this.
#getpids        #need to decide if this is redudnant/problematic
               #it isn't, only insofar as NOTHING in the script uses it anymore.

if [[ "$1" != --exec ]]; then

  (( verbose )) && printf 'In %s.\n' "startupcheck block"

## first determine if there's an ipc command passed

if [[ " ${ipcargs[*]} " = *" $1 "* ]]; then
  ipccmd="$1"
  shift
  [[ "$1" =~ ^[0-9]+$ ]] && ipcval="$1" && shift

  if (( $# )); then
    printf 'The IPC wrapper accepts EXACTLY ONE of the following cli arguments:\n%s\nThe following will be ignored:\n %s\n' "$(IFS=\|; printf '%s' "${ipcargs[*]}")" "$*"
    set --
  elif [[ " ${ipc1args[*]} " = *" $ipccmd " ]] && [[ "$ipcval" ]]; then
    printf 'These IPC wrapper commands do not accept numeric arguments:\n%s\nThe following will be ignored:\n %s\n' "$(IFS=\|; printf '%s' "${ipc1args[*]}")" "$ipcval"
    unset ipcval
  elif [[ " ${ipc2args[*]} " = *" $ipccmd " ]] && [[ ! "$ipcval" ]]; then
    printf 'These IPC wrapper commands require a numeric argument:\n%s' "$(IFS=\|; printf '%s' "${ipc2args[*]}")"
    exit 1
  fi

  printf '%s%s\n' "$ipccmd" "${ipcval:+ $ipcval}" > "$cmdfile"

## run balance of startupcheck() after validating the ipc commands to get "$mpdlingerpid"
#  startupcheck "ipc"
  ipc=1

fi






  ## if pidfile exists, check if pid still running; if stale remove pidfile and unset mpdlingerpid
  if [[ -f "$pidfile" ]]; then
    mpdlingerpid="$(< "$pidfile")"
    (( verbose )) && read -rp "$mpdlingerpid"
    if ! ps -p "$mpdlingerpid" > /dev/null; then
      printf 'Stale pidfile found, removing: %s\n' "$pidfile"
      rm -f "$pidfile"
      unset mpdlingerpid
    else
      pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"
      export mpdlingerpid="$mpdlingerpid"
    fi
  fi

  ## if no valid pidfile found, try to find running mpdlinger processes excluding this shell and edits
  if [[ ! -f "$pidfile" ]] || [[ ! "$mpdlingerpid" ]]; then
    (( verbose )) && printf 'pid of this process: $$ = %s\n' "$$"

    readarray -t pgrepout < <(pgrep mpdlinger -a | grep -Ev -- "$$|--edit")

    ## get our process group id for comparison
    pgid2=$(ps -o pgid= -p $$ | tr -d ' ')
    (( verbose )) && printf '%s\n' "$pgid2"

    ## filter out any pids in same pgid as us (screen or exec children)
    for i in "${pgrepout[@]}"; do
      unset pidpgid   ## make sure we're not reusing a stale value
      pid="${i%% *}"
      pidpgid=$(ps -o pgid= -p "$pid" | tr -d ' ')
      (( verbose )) && printf 'pid=%s  pidpgid=%s  ourpgid=%s  cmd=%s\n' "$pid" "$pidpgid" "$pgid2" "$i"

      ## if process is in a different pgid, assume it's an orphaned daemon
      if [[ "$pidpgid" && "$pidpgid" != "$pgid2" ]]; then
        pgreplines+=("$i")
      fi
    done

    ## show filtered lines if any
    (( verbose )) && { printf -- --\\n; printf '%s\n' "${pgreplines[@]}"; printf -- --\\n; }

    ## if we found any suspicious candidates, prompt user
    if (( ${#pgreplines[@]} )); then
      printf '\n[%sWARN%s] A pid for mpdlinger was identified without a corresponding %s!\n' "$yellow" "$tput0" "$pidfile"
      printf '[%sWARN%s] This indicates that the pidfile has been somehow misplaced...\n\n' "$yellow" "$tput0"
      ## display all the viable candidates
      printf 'Output of '\''%spgrep mpdlinger -a|grep -Ev -- "$$|--edit"%s'\'':\n' "$blue" "$tput0"
      printf '%s' "$blue"

      ## use gum if more than one line, otherwise just print
      if (( ${#pgreplines[@]} > 1 )); then
        mpdlingerpid="$(printf '%s\n' "${pgreplines[@]}" | gum choose)"
        mpdlingerpid="${mpdlingerpid%% *}"
      else
        printf '%s\n' "${pgreplines[0]}"
        mpdlingerpid="${pgreplines[0]%% *}"
      fi
      printf '%s' "$tput0"

      printf \\n

      ## prompt before writing to file, and get pgid again
      confirm -Y "${red}Write pid $mpdlingerpid to $pidfile?${tput0}" &&
        { printf '%s\n' "$mpdlingerpid" > "$pidfile"
          export mpdlingerpid="$mpdlingerpid"
          pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"; } ||
        ## bail out if confirmation fails
        { printf '\nFailed to determine a pid for the daemon. Investigate. (exit 1)\n\n'; exit 1; }
    fi
  fi

## this was the start of the old startupcheck() and shouldn't be run when an ipc command is passed
  if ! (( ipc )); then
    ## compact pids array excluding --edit processes
    readarray -t pids < <(pgrep mpdlinger)
    for i in "${!pids[@]}"; do
      (( verbose )) && printf 'i=%s\n' "$i"
      (( verbose )) && ps -p "${pids[i]}" -o command --no-header
      [[ "$(ps -p "${pids[i]}" -o command --no-header)" = *\ --edit* ]] && unset 'pids[i]'
    done
    pids=("${pids[@]}")

    (( verbose )) && printf 'Array compacted, ${#pids[@]}: %s\n' "${#pids[@]}"
    (( verbose )) && printf '${pids[@]} = %s\n' "${pids[@]}"
    (( verbose )) && printf '$mpdlingerpid = %s\n' "$mpdlingerpid"
    (( verbose )) && (( mpdlingerpid )) &&
                     printf 'ps -p %s = %s\n' "$mpdlingerpid" "$(ps -p $mpdlingerpid)"
    (( verbose )) && printf 'ls %s:\n%s\n' "$pidfile" "$(ls "$pidfile" 2>/dev/null)"
    (( verbose )) && printf 'cat %s:\n%s\n' "$pidfile" "$(cat "$pidfile" 2>/dev/null)"
    (( verbose )) && pause "Pause in ${FUNCNAME[0]}..."

    ## check if an existing mpdlinger screen session is running and try to resume it (skip if we're the same process)
    if (( mpdlingerpid )) && (( mpdlingerpid != $$ )) && ps -p "$mpdlingerpid" >/dev/null && screenpid="$(screen -ls | grep -m1 mpdlinger)"; then
      printf '\nAn instance of mpdlinger is already running in a screen process:\n%s\n' "$screenpid"
      printf '\nAttempting to resume screen...\n\n'
      (( verbose )) && read -rp 'exec screen -r "$(awk '\''{print $1}'\'' <<< "$screenpid")"'
      exec screen -r "$(awk '{print $1}' <<< "$screenpid")"
      printf 'Unable to reattach to the screen that mpdlinger is running on.\n'
      confirm -Y 'Try to reattach with "screen -x" to attempt attaching to a non-detached screen?' &&
        exec screen -r "$(awk '{print $1}' <<< "$screenpid")"
      printf 'Reattachment to screen aborted or failed.\nExiting (exit 1)\n.'
      (( verbose )) && read -rp pause\ before\ exit\ 1
      exit 1

    ## check if an mpdlinger process is running outside screen, error out so user can handle it
    elif (( mpdlingerpid )) && (( mpdlingerpid != $$ )) && ps -p "$mpdlingerpid" >/dev/null; then
      [[ "$(ps -o stat= -p "$mpdlingerpid")" = "S" ]] && background=1
      printf 'An instance of mpdlinger is already running (not in a named screen process):\n'
      ! (( background )) && printf 'You will need to chase it down in another window or kill it (pid=%s).\nExiting (exit 1)\n.' "$mpdlingerpid"
      (( background )) && printf 'You will need to chase it down somewhere in the background or kill it (pid=%s).\nExiting (exit 1)\n.' "$mpdlingerpid"
      (( verbose )) && read -rp pause\ before\ exit\ 2
      exit 1

    ## if multiple mpdlinger pids found, error out for manual cleanup
    elif (( "${#pids[@]}" > 1 )); then
      printf 'There is more than one instance of mpdlinger running:\n%s\n\n' "$(read -rp "$(pgrep mpdlinger -a)")"
      printf 'Exiting. (exit 1)'
      (( verbose )) && read -rp pause\ before\ exit\ 3
      exit 1

    ## finally, set mpdlingerpid to us and write pidfile if none of above apply
    else
      mpdlingerpid="$$"
      printf %s\\n "$mpdlingerpid" > "$pidfile"
      export mpdlingerpid="$mpdlingerpid"
   #   [[ -f "$cmdfile" ]] && rm "$cmdfile"
    fi

## in the case ipc=1, process the validaded ipccommand
## HOEWEVER, WE STILL NEED TO LAUNCH A DAEMON IF ONE DOESN'T EXIST YET!!!
## i.e., if there's no $pidfile or $mpdlingerpid and we feel that is accurate, try launching the daemon to screen.  if that fails, then exit?
  else
if [[ ! "$mpdlingerpid" ]]; then
  printf 'No running mpdlinger daemon found. Would you like to launch one in screen?'
  confirm -Y 'Launch mpdlinger now?' && {
#    screen -S mpdlinger -dm bash -c 'exec ~/bin/mpdlinger'
## maybe don't pass "$@" here?
    mpdlinger -s "$@"
    sleep 1
    if [[ -f "$pidfile" ]]; then
      mpdlingerpid="$(< "$pidfile")"
      pgid="$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')"
      export mpdlingerpid pgid
    else
      printf 'Failed to launch mpdlinger daemon or pidfile not created. (exit 1)\n'
      exit 1
    fi
  } || {
    printf 'Cannot send IPC command without running daemon. (exit 1)\n'
    exit 1
  }
fi
    (( verbose )) && printf 'kill -USR2 %s\n' "$mpdlingerpid"
    [[ ! "$pgid" ]] && pgid=$(ps -o pgid= -p "$mpdlingerpid" | tr -d ' ')
    kill -USR2 "$mpdlingerpid"
    pkill -g "$pgid" mpc
    pkill -g "$pgid" lolcat
    [[ "$ipccmd" = next ]] && mpctitle
    exit 0
  fi

  (( verbose )) && printf 'Leaving %s...' "startupcheck block"
fi # for if [[ "$1" != @(--edit|--exec|--help|-h|help)...

while (( "$#" > 0 )); do
  if [[ "$1" = @(-s|--screen@(|ed)) ]]; then
    screenname="mpdlinger-$(date -Im)"
    screenname="${screenname:0:26}"
    shift
  elif [[ "$1" = @(-a|-as|-sa) ]]; then
    screenname="mpdlinger-$(date -Im)"
    screenname="${screenname:0:26}"
    attached=1
    shift
  elif [[ "$1" = --exec ]]; then
    (( verbose )) && printf 'mpdlinger called with --exec option for internal control.\n'
    execoption=1
    shift
  elif [[ "$1" = @(-v|--verbose) ]]; then
    verbose=1
    args+=("$1")
    shift
  elif [[ "$1" = -p ]]; then
    args+=("$1")
    paused=1
    shift
  elif [[ "$1" =~ ^(-h|--help|help)$ ]]; then
    showhelp
    exit 0
  elif [[ "$1" =~ (--off|--on) ]]; then
    args+=("$1")
    initrand="${1#--}"
    shift
  elif [[ "$1" =~ ^-c([0-9]+)$ || "$1" = -c ]]; then
#    if [[ "$1" =~ ^-c([0-9]+)$ ]]; then
    if [[ "${BASH_REMATCH[1]}" ]]; then
      args+=("$1")
      count="${BASH_REMATCH[1]}"
      shift
    elif [[ "$1" = -c ]]; then
      args+=("$1" "$2")
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        count="$2"
        shift 2
      else
        echo "Error: -c requires a numerical argument."
        exit 1
      fi
    fi
#    if [[ "$mpdlingerpid" ]]; then
#      echo "$count" > "$countfile"
#      export count
#      kill -USR1 "$mpdlingerpid"
#      (( verbose )) && echo "count: $count"
#    fi
  elif [[ "$1" =~ ^-l([0-9]+)$ || "$1" = -l ]]; then
#    if [[ "$1" =~ ^-l([0-9]+)$ ]]; then
    if [[ "${BASH_REMATCH[1]}" ]]; then
      args+=("$1")
      limit="${BASH_REMATCH[1]}"
      shift
    elif [[ "$1" = -l ]]; then
      args+=("$1" "$2")
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        limit="$2"
        shift 2
      else
        printf 'Error: -l requires a numerical argument.\n'
        exit 1
      fi
    fi
  elif [[ "$1" =~ ^-b[0-9]+$ || "$1" = -b ]]; then
#    if [[ "$1" =~ ^-b([0-9]+)$ ]]; then
    if [[ "${BASH_REMATCH[1]}" ]]; then
      args+=("$1")
      blocklimit="${BASH_REMATCH[1]}"
      shift
    elif [[ "$1" = -b ]]; then
      args+=("$1" "$2")
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        blocklimit="$2"
        shift 2
      else
        printf 'Error: -b requires a numerical argument.\n'
        exit 1
      fi
    fi
  elif [[ " ${ipcargs[*]} " = *" $1 "* ]];
    #ipccmd="$1"
    printf %s "$1"
    shift
    [[ "$1" =~ ^[0-9]+$ ]] && { printf \ %s\\n "$1"; shift; } #ipcval="$1" && shift
    read -rp 'An IPC command has been removed from the flag processing block.'
  else
    echo "Unknown option: $1"
    shift
  fi
done


if [[ "$screenname" ]]; then
  (( verbose )) && pause "$screenname"
  hr2 "$bold Calling mpdlinger in GNU screen $tput0"
  [[ -d "$musicdir" ]] && cd "$musicdir" || cd "$HOME" || cd /
  printf \\n\\n
#  screenargs=( screen )
#  (( attached )) && screenargs+=( -mS ) || screenargs+=( -dmS )
#  screenargs+=( "${screenname:0:26}" mpdlinger "${args[@]}" )
#  screen -dmS "${screenname:0:26}" mpdlinger "${args[@]}"
#  (( verbose )) && read -rp "screenargs[*]: $(printf %s\\n "${screenargs[*]}")"
#  (( attached )) && exec env attached=1 "${screenargs[@]}" || "${screenargs[@]}"
  if (( attached )); then
    [[ -e "$pidfile" ]] && [[ "$(< "$pidfile")" != $$ ]] &&
      { printf 'Warning: %s already exists. Aborting to avoid PID confusion.\n' "$pidfile"
      exit 1; }

    exec screen -S "$screenname" bash -c 'echo $$ > /tmp/mpdlinger.pid
                                          exec env attached=1 mpdlinger '"${args[@]}"' '
  else
    screen -dmS "$screenname" mpdlinger "${args[@]}"
  # "${screenargs[@]}"
  fi

  screen -ls
  exit
fi

. <(mpd-current.py)

! [[ "$current" ]] && current="$song_id"

#! [[ "$current" ]] && . <(mpd-current.py) && current="$song_id"

# handle the -p / paused entry state:
if (( paused )); then
#  echo "pauseloop"|"${lolargs[@]}"
  pauseloop
fi


# check to make sure random is off when $0 starts:
if [[ "$initrand" = off ]] || { [[ "$random" = '✅' ]] && (( count < limit )); }; then
  echo "[WARN] Turning random off."
  mpcp -q random off
elif [[ "$initrand" = on ]] || { [[ "$random" = '❌' ]] && (( count >= limit )); }; then
  echo "[WARN] Turning random on."
  mpcp -q random on
fi


clear -x
printf '%s \n%s \n%s \n \n%s\n%s\n' \
       "$(toilet -tf "$font1" "$artist / $title")" \
       "$(toilet -tf "$font1" "$album:")" \
       "$(toilet -tf "$font1" "${blocklimit:+Blocklimit: }$count/$limit")" \
       "$(mpctitle)" \
       "$(date)" |
   "${lolargs[@]}" &

# oneline this with: printf '%s \n%s \n%s \n \n%s\n ' "$(toilet -tf "$font1" "$artist")" "$(toilet -tf "$font1" "$album:")" "$(toilet -tf "$font1" "$count/$limit")" "$(mpctitle)"



while output=( $(\mpc idle playlist player) ); do
  if [[ "${output[@]}" = playlist\ player ]]; then
    if (( paused )); then
      echo "mpdlinger paused. Waiting to be resumed..."
      pauseloop
    #  sleep 1
    #  continue
    fi

    . <(mpd-current.py)

    if (( current != song_id )); then
      current="$song_id"
      ((count++))
    fi
    wait
    clear -x
    randomst=$(( count >= limit ? 1 : 0 ))
    (( randomst )) && randomst='on' || randomst='off'
    printf '%s \n%s \n%s \n \n%s\n%s\n' \
           "$(toilet -tf "$font1" "$artist / $title")" \
           "$(toilet -tf "$font1" "$album:")" \
           "$(toilet -tf "$font1" "${blocklimit:+Blocklimit: }$count/$limit")" \
           "$(mpctitle random $randomst)" \
           "$(date)" |
      "${lolargs[@]}" &
    if (( count >= "$limit" )); then
      count=0
      if (( blocklimit )); then
        limit="$prevlimit"
        unset blocklimit
        printf 'Temporary block limit reached; restoring limit to %s.\nEnjoy the next rock block coming up right after %s!\n' "$limit" "$title"
      fi
    fi
  fi
done



#Character	Name	Unicode	Decimal
#═	Box Drawings Double Horizontal	U+2550	9552
#╤	Box Drawings Down Double and Horizontal Single	U+2564	9572
#
#Arrow Characters
#Character	Name	Unicode	Decimal
#←	Left Arrow	U+2190	8592
#→	Right Arrow	U+2192	8594
#⇐	Left Double Arrow	U+21D0	8656
#⇒	Right Double Arrow	U+21D2	8658
#▶	Black Right-Pointing Triangle	U+25B6	9654
#◀	Black Left-Pointing Triangle	U+25C0	9664


